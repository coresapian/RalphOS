<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>Ralph Dashboard</title>
 <style>
 @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap');
 
 * {
 margin: 0;
 padding: 0;
 box-sizing: border-box;
 }
 
 :root {
 --bg-primary: #0a0a0f;
 --bg-secondary: #12121a;
 --bg-card: #1a1a24;
 --border: #2a2a3a;
 --text-primary: #e4e4e7;
 --text-secondary: #a1a1aa;
 --text-muted: #71717a;
 --accent-cyan: #22d3ee;
 --accent-green: #4ade80;
 --accent-yellow: #facc15;
 --accent-red: #f87171;
 --accent-purple: #a78bfa;
 --accent-blue: #60a5fa;
 }
 
 body {
 font-family: 'Space Grotesk', sans-serif;
 background: var(--bg-primary);
 color: var(--text-primary);
 min-height: 100vh;
 padding: 24px;
 background-image: 
 radial-gradient(ellipse at top left, rgba(34, 211, 238, 0.05) 0%, transparent 50%),
 radial-gradient(ellipse at bottom right, rgba(167, 139, 250, 0.05) 0%, transparent 50%);
 }
 
 .header {
 display: flex;
 align-items: center;
 justify-content: space-between;
 margin-bottom: 32px;
 padding-bottom: 24px;
 border-bottom: 1px solid var(--border);
 }
 
 .logo {
 display: flex;
 align-items: center;
 gap: 16px;
 }
 
 .logo-icon {
 width: 48px;
 height: 48px;
 background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
 border-radius: 12px;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 24px;
 }
 
 .logo h1 {
 font-size: 28px;
 font-weight: 700;
 background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
 -webkit-background-clip: text;
 -webkit-text-fill-color: transparent;
 }
 
 .logo p {
 color: var(--text-muted);
 font-size: 14px;
 }
 
 .status-badge {
 display: flex;
 align-items: center;
 gap: 8px;
 padding: 8px 16px;
 background: var(--bg-card);
 border: 1px solid var(--border);
 border-radius: 999px;
 font-family: 'JetBrains Mono', monospace;
 font-size: 13px;
 }
 
 .status-dot {
 width: 8px;
 height: 8px;
 border-radius: 50%;
 animation: pulse 2s infinite;
 }
 
 .status-dot.running { background: var(--accent-green); }
 .status-dot.stopped { background: var(--accent-red); }
 
 @keyframes pulse {
 0%, 100% { opacity: 1; }
 50% { opacity: 0.5; }
 }
 
 .main-grid {
 display: grid;
 grid-template-columns: 0fr 1fr;
 gap: 24px;
 transition: grid-template-columns 0.4s cubic-bezier(0.4, 0, 0.2, 1);
 }
 
 .main-grid.logs-expanded {
 grid-template-columns: 2fr 1fr;
 }
 
 .card {
 background: var(--bg-card);
 border: 1px solid var(--border);
 border-radius: 16px;
 overflow: hidden;
 }
 
 /* Log Card Collapsible */
 .card.log-card {
 min-width: 0;
 transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
 transform-origin: left center;
 }
 
 .main-grid:not(.logs-expanded) .card.log-card {
 width: 50px;
 min-width: 50px;
 max-width: 50px;
 cursor: pointer;
 }
 
 .main-grid:not(.logs-expanded) .card.log-card .card-header,
 .main-grid:not(.logs-expanded) .card.log-card .card-body {
 opacity: 0;
 pointer-events: none;
 }
 
 .main-grid:not(.logs-expanded) .card.log-card .log-collapsed-tab {
 display: flex;
 }
 
 .log-collapsed-tab {
 display: none;
 position: absolute;
 top: 0;
 left: 0;
 right: 0;
 bottom: 0;
 writing-mode: vertical-rl;
 text-orientation: mixed;
 align-items: center;
 justify-content: center;
 gap: 12px;
 font-size: 13px;
 font-weight: 600;
 color: var(--text-muted);
 background: var(--bg-card);
 border-radius: 16px;
 cursor: pointer;
 transition: all 0.2s;
 }
 
 .log-collapsed-tab:hover {
 background: var(--bg-secondary);
 color: var(--text-primary);
 }
 
 .log-collapsed-tab .log-expand-icon {
 font-size: 18px;
 animation: pulseRight 2s infinite;
 }
 
 @keyframes pulseRight {
 0%, 100% { transform: translateX(0); opacity: 0.6; }
 50% { transform: translateX(3px); opacity: 1; }
 }
 
 /* Sources Card Full Width */
 .card.sources-card {
 transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
 }
 
 .card-header {
 padding: 16px 20px;
 border-bottom: 1px solid var(--border);
 display: flex;
 align-items: center;
 justify-content: space-between;
 }
 
 .card-header h2 {
 font-size: 16px;
 font-weight: 600;
 display: flex;
 align-items: center;
 gap: 8px;
 }
 
 .card-body {
 padding: 20px;
 }
 
.card-body.scrollable {
  max-height: 600px;
  overflow-y: auto;
  contain: content;
  will-change: scroll-position;
 }
 
 .card-body.scrollable::-webkit-scrollbar {
  width: 8px;
 }
 
 .card-body.scrollable::-webkit-scrollbar-track {
  background: var(--bg-secondary);
 }
 
 .card-body.scrollable::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 4px;
 }
 
 .card-body.scrollable::-webkit-scrollbar-thumb:hover {
  background: var(--accent-cyan);
 }
 
.log-output {
  font-family: 'JetBrains Mono', monospace;
  font-size: 12px;
  line-height: 1.6;
  background: var(--bg-primary);
  border-radius: 8px;
  padding: 16px;
  height: 400px;
  overflow-y: auto;
  white-space: pre-wrap;
  word-break: break-all;
  contain: content;
  will-change: scroll-position;
  scroll-behavior: auto;
 }
 
 .log-output::-webkit-scrollbar {
 width: 8px;
 }
 
 .log-output::-webkit-scrollbar-track {
 background: var(--bg-secondary);
 }
 
 .log-output::-webkit-scrollbar-thumb {
 background: var(--border);
 border-radius: 4px;
 }
 
.source-item {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 12px;
  margin: 0 -12px;
  border-bottom: 1px solid var(--border);
  border-radius: 8px;
  cursor: pointer;
  transition: background-color 0.1s, border-color 0.1s;
  will-change: background-color;
  contain: layout style;
 }
 
 .source-item:hover {
  background: var(--bg-secondary);
  border-color: var(--accent-cyan);
 }
 
 .source-item:active {
  transform: scale(0.995);
 }
 
 .source-item:last-child {
 border-bottom: none;
 }
 
 .source-info {
 display: flex;
 align-items: center;
 gap: 12px;
 flex: 1;
 min-width: 0;
 overflow: hidden;
 }
 
 .source-status {
 width: 12px;
 height: 12px;
 border-radius: 50%;
 cursor: pointer;
 transition: all 0.2s;
 position: relative;
 flex-shrink: 0;
 }
 
 .source-status:hover {
 transform: scale(1.4);
 box-shadow: 0 0 12px currentColor;
 }
 
 /* Completed - desaturated/greyed out */
 .source-status.completed { 
 background: #6b7280; 
 color: #6b7280;
 opacity: 0.5;
 }
 
 /* Active Ralph - slow glow fade orange to green */
 .source-status.in_progress { 
 animation: activeRalphGlow 3s ease-in-out infinite;
 }
 
 @keyframes activeRalphGlow {
 0%, 100% { 
 background: #f97316; /* orange */
 box-shadow: 0 0 8px #f97316, 0 0 16px rgba(249, 115, 22, 0.4);
 }
 50% { 
 background: #22c55e; /* green */
 box-shadow: 0 0 8px #22c55e, 0 0 16px rgba(34, 197, 94, 0.4);
 }
 }
 
 /* Pending - muted, waiting */
 .source-status.pending { 
 background: var(--text-muted); 
 color: var(--text-muted);
 opacity: 0.6;
 }
 
 /* Paused - steady orange glow */
 .source-status.paused { 
 background: #f97316;
 box-shadow: 0 0 6px #f97316, 0 0 12px rgba(249, 115, 22, 0.3);
 animation: pausedGlow 2s ease-in-out infinite;
 }
 
 @keyframes pausedGlow {
 0%, 100% { 
 box-shadow: 0 0 6px #f97316, 0 0 12px rgba(249, 115, 22, 0.3);
 }
 50% { 
 box-shadow: 0 0 10px #f97316, 0 0 20px rgba(249, 115, 22, 0.5);
 }
 }
 
 /* Blocked/Error - rapid red blink */
 .source-status.blocked,
 .source-status.error,
 .source-status.hitl { 
 background: var(--accent-red);
 animation: errorBlink 0.5s ease-in-out infinite;
 }
 
 @keyframes errorBlink {
 0%, 100% { 
 background: #ef4444;
 box-shadow: 0 0 8px #ef4444, 0 0 16px rgba(239, 68, 68, 0.6);
 opacity: 1;
 }
 50% { 
 background: #dc2626;
 box-shadow: 0 0 4px #dc2626;
 opacity: 0.4;
 }
 }
 
 /* Stopped - subtle indicator */
 .source-status.stopped {
 background: #9ca3af;
 opacity: 0.7;
 }
 
 /* Source Action Menu */
 .source-action-menu {
 position: fixed;
 background: var(--bg-card);
 border: 1px solid var(--border);
 border-radius: 12px;
 padding: 8px 0;
 min-width: 200px;
 box-shadow: 0 10px 40px rgba(0,0,0,0.5);
 z-index: 1000;
 display: none;
 }
 
 .source-action-menu.visible {
 display: block;
 animation: menuFadeIn 0.15s ease-out;
 }
 
 @keyframes menuFadeIn {
 from { opacity: 0; transform: translateY(-8px); }
 to { opacity: 1; transform: translateY(0); }
 }
 
 .source-action-menu-header {
 padding: 8px 16px 12px;
 border-bottom: 1px solid var(--border);
 margin-bottom: 8px;
 }
 
 .source-action-menu-header .name {
 font-weight: 600;
 font-size: 14px;
 color: var(--text-primary);
 }
 
 .source-action-menu-header .url {
 font-size: 11px;
 color: var(--text-muted);
 font-family: 'JetBrains Mono', monospace;
 margin-top: 4px;
 overflow: hidden;
 text-overflow: ellipsis;
 white-space: nowrap;
 }
 
 .source-action-item {
 padding: 10px 16px;
 display: flex;
 align-items: center;
 gap: 10px;
 cursor: pointer;
 transition: background 0.15s;
 font-size: 13px;
 }
 
 .source-action-item:hover {
 background: var(--bg-secondary);
 }
 
 .source-action-item .icon {
 width: 20px;
 text-align: center;
 }
 
 .source-action-item.start { color: var(--accent-green); }
 .source-action-item.stop { color: var(--accent-red); }
 .source-action-item.generate { color: var(--accent-cyan); }
 .source-action-item.view { color: var(--accent-purple); }
 .source-action-item.disabled {
 opacity: 0.4;
 pointer-events: none;
 }
 
 .source-action-divider {
 height: 1px;
 background: var(--border);
 margin: 8px 0;
 }
 
 .source-name {
 font-weight: 500;
 white-space: nowrap;
 overflow: hidden;
 text-overflow: ellipsis;
 }
 
 .source-stats {
 font-family: 'JetBrains Mono', monospace;
 font-size: 11px;
 color: var(--text-muted);
 white-space: nowrap;
 overflow: hidden;
 text-overflow: ellipsis;
 }
 
.progress-bar {
  flex: 1;
  min-width: 60px;
  max-width: 350px;
  height: 6px;
  background: var(--bg-primary);
  border-radius: 3px;
  overflow: hidden;
  contain: strict;
 }
 
 .progress-bar-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent-cyan), var(--accent-green));
  transition: width 0.2s ease-out;
  will-change: width;
 }
 
 /* Header Pipeline Stats */
 .header-pipeline {
 display: flex;
 align-items: center;
 gap: 8px;
 padding: 8px 16px;
 background: var(--bg-secondary);
 border: 1px solid var(--border);
 border-radius: 12px;
 position: absolute;
 left: 343px;
 top: 22px;
 }
 
 .header-stage {
 display: flex;
 flex-direction: column;
 align-items: center;
 padding: 6px 16px;
 border-radius: 8px;
 min-width: 80px;
 transition: all 0.2s;
 }
 
 .header-stage.active {
 background: rgba(34, 211, 238, 0.1);
 }
 
 .header-stage.complete {
 background: rgba(74, 222, 128, 0.1);
 }
 
 .header-stage-value {
 font-family: 'JetBrains Mono', monospace;
 font-size: 16px;
 font-weight: 700;
 color: var(--text-primary);
 }
 
 .header-stage.active .header-stage-value { color: var(--accent-cyan); }
 .header-stage.complete .header-stage-value { color: var(--accent-green); }
 
 .header-stage-label {
 font-size: 10px;
 color: var(--text-muted);
 text-transform: uppercase;
 letter-spacing: 0.5px;
 }
 
 .header-stage-arrow {
 color: var(--text-muted);
 font-size: 14px;
 }
 
 .refresh-time {
 font-size: 11px;
 color: var(--text-muted);
 font-family: 'JetBrains Mono', monospace;
 display: flex;
 align-items: center;
 gap: 6px;
 }
 
 .live-dot {
 width: 6px;
 height: 6px;
 border-radius: 50%;
 background: var(--accent-green);
 animation: livePulse 2s infinite;
 }
 
 @keyframes livePulse {
 0%, 100% { opacity: 1; transform: scale(1); }
 50% { opacity: 0.4; transform: scale(0.8); }
 }
 
 .live-dot.error {
 background: var(--accent-red);
 animation: none;
 }
 
 .sources-controls {
 display: flex;
 gap: 8px;
 }
 
 .sources-filter-input {
 flex: 1;
 padding: 8px 12px;
 background: var(--bg-primary);
 border: 1px solid var(--border);
 border-radius: 6px;
 color: var(--text-primary);
 font-family: 'JetBrains Mono', monospace;
 font-size: 12px;
 outline: none;
 transition: border-color 0.2s;
 }
 
 .sources-filter-input:focus {
 border-color: var(--accent-cyan);
 }
 
 .sources-filter-input::placeholder {
 color: var(--text-muted);
 }
 
 .sources-sort-select {
 padding: 8px 12px;
 background: var(--bg-primary);
 border: 1px solid var(--border);
 border-radius: 6px;
 color: var(--text-primary);
 font-family: 'JetBrains Mono', monospace;
 font-size: 12px;
 outline: none;
 cursor: pointer;
 transition: border-color 0.2s;
 }
 
 .sources-sort-select:focus,
 .sources-sort-select:hover {
 border-color: var(--accent-cyan);
 }
 
.no-results {
  text-align: center;
  padding: 24px;
  color: var(--text-muted);
  font-size: 13px;
 }
 
 .load-more {
  text-align: center;
  padding: 12px;
  color: var(--accent-cyan);
  font-size: 13px;
  cursor: pointer;
  border-radius: 8px;
  transition: background 0.15s;
 }
 
 .load-more:hover {
  background: var(--bg-secondary);
 }
 
 .error { color: var(--accent-red); }
 .success { color: var(--accent-green); }
 .warning { color: var(--accent-yellow); }
 .info { color: var(--accent-cyan); }
 
 /* Scraper Panel Styles */
 .scraper-panel {
 background: var(--bg-card);
 border: 1px solid var(--border);
 border-radius: 16px;
 margin-bottom: 24px;
 overflow: hidden;
 }
 
 .scraper-header {
 padding: 16px 20px;
 border-bottom: 1px solid var(--border);
 display: flex;
 align-items: center;
 justify-content: space-between;
 cursor: pointer;
 transition: background 0.2s;
 }
 
 .scraper-header:hover {
 background: var(--bg-secondary);
 }
 
 .scraper-header h2 {
 font-size: 16px;
 font-weight: 600;
 display: flex;
 align-items: center;
 gap: 8px;
 }
 
 .scraper-toggle {
 font-size: 18px;
 transition: transform 0.3s;
 }
 
 .scraper-toggle.open {
 transform: rotate(180deg);
 }
 
 .scraper-body {
 padding: 20px;
 display: none;
 }
 
 .scraper-body.open {
 display: block;
 }
 
 .form-grid {
 display: grid;
 grid-template-columns: repeat(3, 1fr);
 gap: 16px;
 margin-bottom: 20px;
 }
 
 .form-group {
 display: flex;
 flex-direction: column;
 gap: 6px;
 }
 
 .form-group.full-width {
 grid-column: span 3;
 }
 
 .form-group label {
 font-size: 12px;
 color: var(--text-muted);
 text-transform: uppercase;
 letter-spacing: 0.5px;
 }
 
 .form-group input,
 .form-group select {
 padding: 10px 14px;
 background: var(--bg-primary);
 border: 1px solid var(--border);
 border-radius: 8px;
 color: var(--text-primary);
 font-family: 'JetBrains Mono', monospace;
 font-size: 13px;
 transition: border-color 0.2s;
 }
 
 .form-group input:focus,
 .form-group select:focus {
 outline: none;
 border-color: var(--accent-cyan);
 }
 
 .form-group input::placeholder {
 color: var(--text-muted);
 }
 
 .btn-group {
 display: flex;
 gap: 12px;
 }
 
.btn {
  padding: 12px 24px;
  border: none;
  border-radius: 8px;
  font-family: 'Space Grotesk', sans-serif;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: transform 0.1s, box-shadow 0.15s, background-color 0.15s;
  display: flex;
  align-items: center;
  gap: 8px;
  will-change: transform;
 }
 
 .btn:active {
  transform: scale(0.97);
 }
 
 .btn-primary {
  background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
  color: var(--bg-primary);
 }
 
 .btn-primary:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(34, 211, 238, 0.3);
 }
 
 .btn-primary:active {
  transform: translateY(0) scale(0.98);
 }
 
 .btn-primary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
 }
 
 .btn-danger {
 background: var(--accent-red);
 color: white;
 }
 
 .btn-danger:hover {
 background: #ef4444;
 }
 
 .btn-secondary {
 background: var(--bg-secondary);
 color: var(--text-primary);
 border: 1px solid var(--border);
 }
 
 .btn-secondary:hover {
 border-color: var(--accent-cyan);
 }
 
 .scraper-status {
 display: flex;
 align-items: center;
 gap: 12px;
 padding: 12px 16px;
 background: var(--bg-primary);
 border-radius: 8px;
 margin-bottom: 16px;
 }
 
 .scraper-status-dot {
 width: 10px;
 height: 10px;
 border-radius: 50%;
 }
 
 .scraper-status-dot.running {
 background: var(--accent-green);
 animation: pulse 2s infinite;
 }
 
 .scraper-status-dot.stopped {
 background: var(--text-muted);
 }
 
 .scraper-stats {
 display: grid;
 grid-template-columns: repeat(4, 1fr);
 gap: 12px;
 margin-top: 16px;
 }
 
 .scraper-stat {
 padding: 12px;
 background: var(--bg-primary);
 border-radius: 8px;
 text-align: center;
 }
 
 .scraper-stat .stat-label {
 font-size: 10px;
 color: var(--text-muted);
 text-transform: uppercase;
 margin-bottom: 4px;
 }
 
 .scraper-stat .stat-value {
 font-family: 'JetBrains Mono', monospace;
 font-size: 18px;
 font-weight: 600;
 }
 
 .scraper-stat.green .stat-value { color: var(--accent-green); }
 .scraper-stat.red .stat-value { color: var(--accent-red); }
 .scraper-stat.yellow .stat-value { color: var(--accent-yellow); }
 .scraper-stat.cyan .stat-value { color: var(--accent-cyan); }
 
 .help-text {
 font-size: 11px;
 color: var(--text-muted);
 margin-top: 4px;
 }
 
 .preset-buttons {
 display: flex;
 gap: 8px;
 margin-bottom: 16px;
 }
 
 .preset-btn {
 padding: 6px 12px;
 background: var(--bg-secondary);
 border: 1px solid var(--border);
 border-radius: 6px;
 color: var(--text-secondary);
 font-size: 11px;
 cursor: pointer;
 transition: all 0.2s;
 }
 
 .preset-btn:hover {
 border-color: var(--accent-cyan);
 color: var(--accent-cyan);
 }
 
 .preset-btn.active {
 background: rgba(34, 211, 238, 0.1);
 border-color: var(--accent-cyan);
 color: var(--accent-cyan);
 }
 
 .scraper-log {
 font-family: 'JetBrains Mono', monospace;
 font-size: 11px;
 background: var(--bg-primary);
 border-radius: 8px;
 padding: 12px;
 max-height: 200px;
 overflow-y: auto;
 white-space: pre-wrap;
 margin-top: 16px;
 display: none;
 }
 
 .scraper-log.visible {
 display: block;
 }
 
 /* Ralph Panel Styles */
 .ralph-panel {
 background: linear-gradient(135deg, rgba(74, 222, 128, 0.05), rgba(34, 211, 238, 0.05));
 border: 1px solid var(--accent-green);
 border-radius: 16px;
 margin-bottom: 24px;
 overflow: hidden;
 }
 
 .ralph-header {
 padding: 16px 20px;
 border-bottom: 1px solid var(--border);
 display: flex;
 align-items: center;
 justify-content: space-between;
 cursor: pointer;
 transition: background 0.2s;
 }
 
 .ralph-header:hover {
 background: rgba(74, 222, 128, 0.1);
 }
 
 .ralph-header h2 {
 font-size: 16px;
 font-weight: 600;
 display: flex;
 align-items: center;
 gap: 8px;
 color: var(--accent-green);
 }
 
 .ralph-body {
 padding: 20px;
 display: none;
 }
 
 .ralph-body.open {
 display: block;
 }
 
 .ralph-status {
 display: flex;
 align-items: center;
 gap: 16px;
 padding: 16px;
 background: var(--bg-primary);
 border-radius: 12px;
 margin-bottom: 16px;
 }
 
 .ralph-status-indicator {
 display: flex;
 align-items: center;
 gap: 8px;
 }
 
 .ralph-info {
 flex: 1;
 }
 
 .ralph-info .project-name {
 font-weight: 600;
 color: var(--accent-green);
 }
 
 .ralph-info .story-progress {
 font-size: 12px;
 color: var(--text-muted);
 margin-top: 4px;
 }
 
 .iterations-input {
 display: flex;
 align-items: center;
 gap: 12px;
 margin-bottom: 16px;
 }
 
 .iterations-input label {
 font-size: 13px;
 color: var(--text-secondary);
 }
 
 .iterations-input input {
 width: 80px;
 padding: 8px 12px;
 background: var(--bg-primary);
 border: 1px solid var(--border);
 border-radius: 6px;
 color: var(--text-primary);
 font-family: 'JetBrains Mono', monospace;
 text-align: center;
 }
 
 .log-controls {
 display: flex;
 align-items: center;
 gap: 8px;
 margin-left: auto;
 }
 
 .log-collapse-btn {
 padding: 4px 10px;
 background: var(--bg-secondary);
 border: 1px solid var(--border);
 border-radius: 6px;
 color: var(--text-muted);
 font-size: 14px;
 cursor: pointer;
 transition: all 0.2s;
 margin-left: 12px;
 }
 
 .log-collapse-btn:hover {
 background: var(--bg-tertiary);
 color: var(--text-primary);
 border-color: var(--accent-red);
 }
 
 .log-controls button {
 padding: 4px 8px;
 background: var(--bg-secondary);
 border: 1px solid var(--border);
 border-radius: 4px;
 color: var(--text-secondary);
 font-size: 11px;
 cursor: pointer;
 }
 
 .log-controls button:hover {
 border-color: var(--accent-cyan);
 color: var(--accent-cyan);
 }
 
 .log-controls button.active {
 background: rgba(34, 211, 238, 0.2);
 border-color: var(--accent-cyan);
 color: var(--accent-cyan);
 }
 
 .log-controls button.kill-btn {
 background: rgba(248, 113, 113, 0.15);
 border-color: var(--accent-red);
 color: var(--accent-red);
 font-weight: 600;
 }
 
 .log-controls button.kill-btn:hover {
 background: rgba(248, 113, 113, 0.3);
 border-color: var(--accent-red);
 color: var(--accent-red);
 }
 
 .log-controls button.kill-btn.killing {
 animation: pulse-red 0.5s infinite;
 pointer-events: none;
 }
 
 @keyframes pulse-red {
 0%, 100% { opacity: 1; }
 50% { opacity: 0.5; }
 }
 
 .auto-scroll-indicator {
 font-size: 10px;
 color: var(--text-muted);
 }
 
 /* Source Pagination */
 .log-source-pagination {
 display: flex;
 align-items: center;
 gap: 8px;
 margin-left: 16px;
 padding: 4px 8px;
 background: var(--bg-primary);
 border-radius: 8px;
 border: 1px solid var(--border);
 }
 
 .log-source-arrow {
 width: 28px;
 height: 28px;
 display: flex;
 align-items: center;
 justify-content: center;
 background: var(--bg-secondary);
 border: 1px solid var(--border);
 border-radius: 6px;
 color: var(--text-secondary);
 font-size: 14px;
 cursor: pointer;
 transition: all 0.2s;
 user-select: none;
 }
 
 .log-source-arrow:hover {
 border-color: var(--accent-cyan);
 color: var(--accent-cyan);
 background: rgba(34, 211, 238, 0.1);
 }
 
 .log-source-arrow:active {
 transform: scale(0.95);
 }
 
 .log-source-arrow.disabled {
 opacity: 0.3;
 cursor: not-allowed;
 pointer-events: none;
 }
 
 .log-source-indicator {
 display: flex;
 flex-direction: column;
 align-items: center;
 min-width: 140px;
 padding: 0 8px;
 }
 
 .log-source-name {
 font-size: 12px;
 font-weight: 600;
 color: var(--accent-cyan);
 white-space: nowrap;
 overflow: hidden;
 text-overflow: ellipsis;
 max-width: 140px;
 }
 
 .log-source-name.all-sources {
 color: var(--accent-purple);
 }
 
 .log-source-counter {
 font-size: 10px;
 color: var(--text-muted);
 }
 
 .log-source-status {
 width: 8px;
 height: 8px;
 border-radius: 50%;
 margin-right: 6px;
 display: inline-block;
 }
 
 .log-source-status.running {
 background: var(--accent-green);
 animation: pulse 2s infinite;
 }
 
 .log-source-status.completed {
 background: var(--accent-cyan);
 }
 
 .log-source-status.pending {
 background: var(--accent-yellow);
 }
 
 .log-source-status.blocked {
 background: var(--accent-red);
 }
 
 /* Settings Button */
 .settings-btn {
 width: 40px;
 height: 40px;
 border-radius: 10px;
 border: 1px solid var(--border);
 background: var(--bg-card);
 font-size: 18px;
 cursor: pointer;
 transition: all 0.2s;
 display: flex;
 align-items: center;
 justify-content: center;
 }
 
 .settings-btn:hover {
 border-color: var(--accent-cyan);
 background: var(--bg-secondary);
 transform: rotate(30deg);
 }
 
 /* Settings Panel Overlay */
 .settings-overlay {
 position: fixed;
 inset: 0;
 background: rgba(0, 0, 0, 0.7);
 backdrop-filter: blur(4px);
 z-index: 2500;
 display: none;
 align-items: flex-start;
 justify-content: flex-end;
 padding: 24px;
 }
 
 .settings-overlay.visible {
 display: flex;
 animation: fadeIn 0.2s ease-out;
 }
 
 .settings-panel {
 width: 500px;
 max-height: calc(100vh - 48px);
 background: var(--bg-card);
 border: 1px solid var(--border);
 border-radius: 16px;
 overflow: hidden;
 display: flex;
 flex-direction: column;
 animation: slideIn 0.3s ease-out;
 }
 
 @keyframes slideIn {
 from { opacity: 0; transform: translateX(20px); }
 to { opacity: 1; transform: translateX(0); }
 }
 
 .settings-header {
 padding: 20px 24px;
 border-bottom: 1px solid var(--border);
 display: flex;
 align-items: center;
 justify-content: space-between;
 background: var(--bg-secondary);
 }
 
 .settings-header h2 {
 font-size: 18px;
 font-weight: 600;
 display: flex;
 align-items: center;
 gap: 10px;
 }
 
 .settings-close {
 width: 32px;
 height: 32px;
 border: none;
 background: var(--bg-card);
 border-radius: 8px;
 color: var(--text-muted);
 cursor: pointer;
 font-size: 18px;
 transition: all 0.2s;
 }
 
 .settings-close:hover {
 background: var(--accent-red);
 color: white;
 }
 
 .settings-content {
 flex: 1;
 overflow-y: auto;
 padding: 24px;
 }
 
 .settings-section {
 margin-bottom: 24px;
 }
 
 .settings-section-title {
 font-size: 12px;
 text-transform: uppercase;
 letter-spacing: 1px;
 color: var(--text-muted);
 margin-bottom: 12px;
 display: flex;
 align-items: center;
 gap: 8px;
 }
 
 /* Browser Preview Panel */
 
 /* Notification Bell */
 .notif-container {
 position: relative;
 display: flex;
 align-items: center;
 gap: 12px;
 }
 
 .header-kill-btn {
 position: absolute;
 left: 270px;
 top: -19px;
 height: 35px;
 width: 100px;
 padding: 0 14px;
 border-radius: 10px;
 border: 1px solid var(--accent-red);
 background: rgba(248, 113, 113, 0.15);
 color: var(--accent-red);
 font-size: 13px;
 font-weight: 600;
 cursor: pointer;
 transition: all 0.2s;
 display: flex;
 align-items: center;
 justify-content: center;
 gap: 6px;
 }
 
 .header-kill-btn:hover {
 background: rgba(248, 113, 113, 0.3);
 }
 
 .header-kill-btn.killing {
 animation: pulse-red 0.5s infinite;
 pointer-events: none;
 background: rgba(248, 113, 113, 0.4);
 box-shadow: 0 0 20px rgba(248, 113, 113, 0.5);
 }
 
 .header-kill-btn.killed-success {
 background: rgba(74, 222, 128, 0.3);
 border-color: var(--accent-green);
 color: var(--accent-green);
 box-shadow: 0 0 15px rgba(74, 222, 128, 0.4);
 }
 
 .notif-btn {
 width: 40px;
 height: 40px;
 border-radius: 10px;
 border: 1px solid var(--border);
 background: var(--bg-card);
 font-size: 18px;
 cursor: pointer;
 transition: all 0.2s;
 display: flex;
 align-items: center;
 justify-content: center;
 position: absolute;
 left: 385px;
 top: -19px;
 }
 
 .notif-btn:hover {
 border-color: var(--accent-yellow);
 background: rgba(255, 193, 7, 0.1);
 }
 
 .notif-btn.has-alerts {
 animation: notifPulse 2s ease-in-out infinite;
 border-color: var(--accent-red);
 }
 
 @keyframes notifPulse {
 0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
 50% { box-shadow: 0 0 0 8px rgba(239, 68, 68, 0); }
 }
 
 .notif-badge {
 position: absolute;
 top: -4px;
 right: -4px;
 background: var(--accent-red);
 color: white;
 font-size: 10px;
 font-weight: 700;
 min-width: 18px;
 height: 18px;
 border-radius: 9px;
 display: flex;
 align-items: center;
 justify-content: center;
 padding: 0 4px;
 }
 
 .notif-badge:empty {
 display: none;
 }
 
 .notif-dropdown {
 position: absolute;
 top: 50px;
 right: 0;
 width: 380px;
 max-height: 500px;
 background: var(--bg-card);
 border: 1px solid var(--border);
 border-radius: 12px;
 box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
 display: none;
 flex-direction: column;
 z-index: 1000;
 overflow: hidden;
 }
 
 .notif-dropdown.visible {
 display: flex;
 }
 
 .notif-header {
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 12px 16px;
 border-bottom: 1px solid var(--border);
 background: var(--bg-secondary);
 }
 
 .notif-header h3 {
 margin: 0;
 font-size: 14px;
 color: var(--text-primary);
 }
 
 .notif-clear-btn {
 font-size: 11px;
 color: var(--text-muted);
 background: none;
 border: none;
 cursor: pointer;
 padding: 4px 8px;
 border-radius: 4px;
 }
 
 .notif-clear-btn:hover {
 background: var(--bg-tertiary);
 color: var(--text-primary);
 }
 
 .notif-list {
 flex: 1;
 overflow-y: auto;
 max-height: 400px;
 }
 
 .notif-item {
 padding: 12px 16px;
 border-bottom: 1px solid var(--border);
 cursor: pointer;
 transition: background 0.2s;
 }
 
 .notif-item:hover {
 background: var(--bg-secondary);
 }
 
 .notif-item.unread {
 background: rgba(239, 68, 68, 0.05);
 border-left: 3px solid var(--accent-red);
 }
 
 .notif-item-header {
 display: flex;
 justify-content: space-between;
 align-items: flex-start;
 margin-bottom: 6px;
 }
 
 .notif-source {
 font-weight: 600;
 font-size: 13px;
 color: var(--accent-red);
 display: flex;
 align-items: center;
 gap: 6px;
 }
 
 .notif-time {
 font-size: 10px;
 color: var(--text-muted);
 }
 
 .notif-message {
 font-size: 12px;
 color: var(--text-secondary);
 margin-bottom: 8px;
 line-height: 1.4;
 }
 
 .notif-suggestion {
 font-size: 11px;
 color: var(--accent-cyan);
 background: rgba(6, 182, 212, 0.1);
 padding: 8px 10px;
 border-radius: 6px;
 margin-top: 6px;
 }
 
 .notif-suggestion strong {
 display: block;
 margin-bottom: 4px;
 color: var(--accent-cyan);
 }
 
 .notif-actions {
 display: flex;
 gap: 8px;
 margin-top: 8px;
 }
 
 .notif-action-btn {
 font-size: 10px;
 padding: 4px 8px;
 border-radius: 4px;
 border: 1px solid var(--border);
 background: var(--bg-tertiary);
 color: var(--text-secondary);
 cursor: pointer;
 transition: all 0.2s;
 }
 
 .notif-action-btn:hover {
 border-color: var(--accent-cyan);
 color: var(--accent-cyan);
 }
 
 .notif-empty {
 padding: 40px 20px;
 text-align: center;
 color: var(--text-muted);
 }
 
 .notif-empty-icon {
 font-size: 32px;
 margin-bottom: 12px;
 opacity: 0.5;
 background: var(--bg-secondary);
 }
 
 .browser-btn.active {
 border-color: var(--accent-purple);
 background: rgba(167, 139, 250, 0.2);
 }
 
 /* Browser log styling kept for PRD modal browser */
 .browser-log-action {
 color: var(--accent-cyan);
 }
 
 .browser-log-url {
 color: var(--accent-purple);
 word-break: break-all;
 }
 
 .browser-log-error {
 color: var(--accent-red);
 }
 
 .browser-log-success {
 color: var(--accent-green);
 }
 
 .browser-status-dot.loading {
 background: var(--accent-yellow);
 animation: pulse 0.5s infinite;
 }
 /* Loading Screen */
.loading-overlay {
 position: fixed;
 inset: 0;
 background: var(--bg-primary);
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 z-index: 9999;
 transition: opacity 0.5s ease-out, visibility 0.5s ease-out;
}

.loading-overlay.hidden {
 opacity: 0;
 visibility: hidden;
 pointer-events: none;
}

.loading-logo {
 width: 80px;
 height: 80px;
 background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
 border-radius: 20px;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 40px;
 margin-bottom: 24px;
 animation: loadingPulse 2s ease-in-out infinite;
}

@keyframes loadingPulse {
 0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(34, 211, 238, 0.4); }
 50% { transform: scale(1.05); box-shadow: 0 0 30px 10px rgba(34, 211, 238, 0.2); }
}

.loading-title {
 font-size: 28px;
 font-weight: 700;
 background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
 -webkit-background-clip: text;
 -webkit-text-fill-color: transparent;
 margin-bottom: 8px;
}

.loading-subtitle {
 color: var(--text-muted);
 font-size: 14px;
 margin-bottom: 32px;
}

.loading-spinner {
 display: flex;
 gap: 6px;
 margin-bottom: 16px;
}

.loading-spinner span {
 width: 12px;
 height: 12px;
 background: var(--accent-cyan);
 border-radius: 50%;
 animation: loadingBounce 1.4s ease-in-out infinite;
}

.loading-spinner span:nth-child(1) { animation-delay: 0s; }
.loading-spinner span:nth-child(2) { animation-delay: 0.16s; }
.loading-spinner span:nth-child(3) { animation-delay: 0.32s; }
.loading-spinner span:nth-child(4) { animation-delay: 0.48s; }

@keyframes loadingBounce {
 0%, 80%, 100% { transform: scale(0.6); opacity: 0.5; }
 40% { transform: scale(1); opacity: 1; }
}

.loading-status {
 color: var(--text-secondary);
 font-size: 13px;
 font-family: 'JetBrains Mono', monospace;
}

.loading-progress {
 width: 200px;
 height: 3px;
 background: var(--bg-secondary);
 border-radius: 2px;
 margin-top: 16px;
 overflow: hidden;
}

.loading-progress-bar {
 height: 100%;
 background: linear-gradient(90deg, var(--accent-cyan), var(--accent-purple));
 border-radius: 2px;
 animation: loadingProgress 2s ease-in-out infinite;
}

@keyframes loadingProgress {
 0% { width: 0%; margin-left: 0%; }
 50% { width: 60%; margin-left: 20%; }
 100% { width: 0%; margin-left: 100%; }
}
</style>
</head>
<body>
 <!-- Loading Screen -->
 <div class="loading-overlay" id="loadingOverlay">
  <div class="loading-logo">ü§ñ</div>
  <div class="loading-title">RALPH</div>
  <div class="loading-subtitle">Autonomous AI Agent Dashboard</div>
  <div class="loading-spinner">
   <span></span><span></span><span></span><span></span>
  </div>
  <div class="loading-status" id="loadingStatus">Connecting to server...</div>
  <div class="loading-progress"><div class="loading-progress-bar"></div></div>
 </div>

 <div class="header">
 <div class="logo">
 <div class="logo-icon"></div>
 <div>
 <h1>MOTORMIA A.B.C.</h1>
 <p>Autonomous Builds Collection</p>
 </div>
 </div>
 
 <!-- Pipeline Stats (inline) -->
 <div class="header-pipeline" id="pipelineStages">
 <div class="header-stage" id="stage1">
 <span class="header-stage-value">--</span>
 <span class="header-stage-label">URLs</span>
 </div>
 <span class="header-stage-arrow">‚Üí</span>
 <div class="header-stage" id="stage2">
 <span class="header-stage-value">--</span>
 <span class="header-stage-label">HTML</span>
 </div>
 <span class="header-stage-arrow">‚Üí</span>
 <div class="header-stage" id="stage3">
 <span class="header-stage-value">--</span>
 <span class="header-stage-label">Builds</span>
 </div>
 <span class="header-stage-arrow">‚Üí</span>
 <div class="header-stage" id="stage4">
 <span class="header-stage-value">--</span>
 <span class="header-stage-label">Mods</span>
 </div>
 </div>
 
 <div class="notif-container">
 <button id="killAllBtn" class="header-kill-btn" onclick="killAllRalphs()" title="Kill all Ralph processes"> Kill All</button>
 <button class="notif-btn" onclick="toggleNotifications()" title="Alerts & Suggestions" id="notifBtn">
 
 <span class="notif-badge" id="notifBadge"></span>
 </button>
 <div class="notif-dropdown" id="notifDropdown">
 <div class="notif-header">
 <h3> Alerts & Suggestions</h3>
 <button class="notif-clear-btn" onclick="clearAllNotifications()">Clear All</button>
 </div>
 <div class="notif-list" id="notifList">
 <div class="notif-empty">
 <div class="notif-empty-icon"></div>
 <div>No alerts - all systems running smoothly</div>
 </div>
 </div>
 </div>
 </div>
 
 <button class="settings-btn" onclick="toggleSettingsPanel()" title="Settings">
 
 </button>
 </div>
 
 <div class="main-grid" id="mainGrid">
 <div class="card log-card" id="logCard" style="position: relative;">
 <div class="log-collapsed-tab" onclick="toggleLogPanel()">
 <span class="log-expand-icon">‚Üí</span>
 <span> Live Log</span>
 <span class="log-expand-icon">‚Üí</span>
 </div>
 <div class="card-header">
 <div class="status-badge" style="padding: 6px 12px;">
 <div class="status-dot" id="statusDot"></div>
 <span id="statusText">Checking...</span>
 </div>
 <button class="log-collapse-btn" onclick="toggleLogPanel()" title="Collapse log panel"></button>
 
 <!-- Source Pagination -->
 <div class="log-source-pagination">
 <button class="log-source-arrow" onclick="prevLogSource()" title="Previous source" id="logPrevBtn"></button>
 <div class="log-source-indicator">
 <div style="display: flex; align-items: center;">
 <span class="log-source-status" id="logSourceStatus"></span>
 <span class="log-source-name all-sources" id="logSourceName">All Sources</span>
 </div>
 <span class="log-source-counter" id="logSourceCounter">0 of 0</span>
 </div>
 <button class="log-source-arrow" onclick="nextLogSource()" title="Next source" id="logNextBtn"></button>
 </div>
 
 <div class="log-controls">
 <button onclick="refreshLogNow()" title="Refresh now"></button>
 <button id="autoRefreshBtn" class="active" onclick="toggleAutoRefresh()" title="Toggle auto-refresh">Auto</button>
 <button onclick="clearLogDisplay()" title="Clear display">Clear</button>
 <span class="auto-scroll-indicator" id="autoScrollIndicator">‚Üì Auto-scroll ON</span>
 </div>
 <span class="refresh-time" id="logRefresh">--</span>
 </div>
 <div class="card-body">
 <div class="log-output" id="logOutput">Loading...</div>
 </div>
 </div>
 
 <div class="card sources-card" id="sourcesCard">
 <div class="card-header" style="flex-direction: column; align-items: stretch; gap: 12px;">
 <div style="display: flex; justify-content: space-between; align-items: center;">
 <h2 style="display: flex; align-items: center; gap: 16px;">
 Sources
 <span style="display: flex; gap: 12px; font-size: 12px; font-weight: 500;">
 <span style="color: var(--accent-cyan);"><span id="totalSources">--</span> total</span>
 <span style="color: var(--accent-green);"> <span id="completedSources">--</span></span>
 <span style="color: var(--accent-yellow);">‚è≥ <span id="inProgressSources">--</span></span>
 </span>
 </h2>
 <span class="refresh-time" id="sourcesRefresh"><div class="live-dot" id="sourcesLiveDot"></div><span id="sourcesRefreshText">--</span></span>
 </div>
 <div class="sources-controls">
 <input type="text" id="sourcesFilter" placeholder="Filter sources..." class="sources-filter-input">
 <select id="sourcesSort" class="sources-sort-select">
 <option value="progress">Sort: Progress ‚Üì</option>
 <option value="status">Sort: Status</option>
 <option value="name">Sort: Name</option>
 <option value="urls">Sort: URLs ‚Üì</option>
 <option value="html">Sort: HTML ‚Üì</option>
 <option value="builds">Sort: Builds ‚Üì</option>
 </select>
 </div>
 </div>
 <div class="card-body scrollable" id="sourcesList">
 Loading...
 </div>
 </div>
 </div>
 
 <script>
 // Configuration
 const REFRESH_INTERVAL = 5000; // 5 seconds
 const API_BASE = 'http://localhost:8765';
 
 // State
 let isInitialLoad = true;
 let lastLogLines = [];
 let allSources = [];
 let notifications = [];
 
 // Log source pagination state
 let logSourceList = []; // Array of sources with logs (includes "all" as first)
 let currentLogSourceIndex = 0; // 0 = all sources
 let sourceLogCache = {}; // Cache of log content per source
 let analyzedErrors = new Set(); // Track which errors we've already analyzed
 let previousSourceStatuses = {}; // Track status changes
 
 // Debounce for filter
 function debounce(func, wait) {
  let timeout;
  return function(...args) {
   clearTimeout(timeout);
   timeout = setTimeout(() => func.apply(this, args), wait);
  };
 }
 
 // Hide loading screen - bulletproof version
 let loadingHidden = false;
 function hideLoadingScreen() {
  if (loadingHidden) return;
  loadingHidden = true;
  
  const overlay = document.getElementById('loadingOverlay');
  if (!overlay) return;
  
  const status = document.getElementById('loadingStatus');
  if (status) status.textContent = 'Ready!';
  
  // Fade out
  overlay.style.transition = 'opacity 0.3s';
  overlay.style.opacity = '0';
  
  // Remove after fade
  setTimeout(() => {
   overlay.remove();
  }, 350);
 }
 
 // Update loading status
 function updateLoadingStatus(message) {
  if (loadingHidden) return;
  const status = document.getElementById('loadingStatus');
  if (status) status.textContent = message;
 }
 
 // FAILSAFE: Always hide loading screen after 5 seconds no matter what
 setTimeout(() => {
  if (!loadingHidden) {
   console.log('Failsafe: hiding loading screen');
   hideLoadingScreen();
  }
 }, 5000);
 
 // Notification System
 function toggleNotifications() {
 const dropdown = document.getElementById('notifDropdown');
 dropdown.classList.toggle('visible');
 
 // Mark all as read when opened
 if (dropdown.classList.contains('visible')) {
 notifications.forEach(n => n.unread = false);
 updateNotificationBadge();
 renderNotifications();
 }
 }
 
 function closeNotifications() {
 document.getElementById('notifDropdown').classList.remove('visible');
 }
 
 function updateNotificationBadge() {
 const badge = document.getElementById('notifBadge');
 const btn = document.getElementById('notifBtn');
 const unreadCount = notifications.filter(n => n.unread).length;
 
 badge.textContent = unreadCount > 0 ? (unreadCount > 9 ? '9+' : unreadCount) : '';
 btn.classList.toggle('has-alerts', unreadCount > 0);
 }
 
 function addNotification(notification) {
 notifications.unshift({
 id: Date.now(),
 unread: true,
 timestamp: new Date(),
 ...notification
 });
 
 // Keep only last 50 notifications
 if (notifications.length > 50) {
 notifications = notifications.slice(0, 50);
 }
 
 updateNotificationBadge();
 renderNotifications();
 
 // Show toast for new critical notifications
 if (notification.type === 'error') {
 showNotification(` ${notification.source}: ${notification.message}`, 'error');
 }
 }
 
 function renderNotifications() {
 const list = document.getElementById('notifList');
 
 if (notifications.length === 0) {
 list.innerHTML = `
 <div class="notif-empty">
 <div class="notif-empty-icon"></div>
 <div>No alerts - all systems running smoothly</div>
 </div>
 `;
 return;
 }
 
 list.innerHTML = notifications.map(n => `
 <div class="notif-item ${n.unread ? 'unread' : ''}" onclick="viewNotificationDetails('${n.id}')">
 <div class="notif-item-header">
 <span class="notif-source">
 ${n.type === 'error' ? '': n.type === 'warning' ? '': ''} 
 ${n.source}
 </span>
 <span class="notif-time">${formatTimeAgo(n.timestamp)}</span>
 </div>
 <div class="notif-message">${n.message}</div>
 ${n.suggestion ? `
 <div class="notif-suggestion">
 <strong> Suggested Fix:</strong>
 ${n.suggestion}
 </div>
 ` : ''}
 ${n.actions ? `
 <div class="notif-actions">
 ${n.actions.map(a => `
 <button class="notif-action-btn" onclick="event.stopPropagation(); ${a.action}">${a.label}</button>
 `).join('')}
 </div>
 ` : ''}
 </div>
 `).join('');
 }
 
 function formatTimeAgo(date) {
 const seconds = Math.floor((new Date() - new Date(date)) / 1000);
 if (seconds < 60) return 'just now';
 if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
 if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
 return `${Math.floor(seconds / 86400)}d ago`;
 }
 
 function clearAllNotifications() {
 notifications = [];
 analyzedErrors.clear();
 updateNotificationBadge();
 renderNotifications();
 }
 
 function viewNotificationDetails(id) {
 const notif = notifications.find(n => n.id == id);
 if (notif && notif.sourceId) {
 closeNotifications();
 openPrdModal(notif.sourceId, notif.source, notif.sourceUrl);
 }
 }
 
 // Error Detection and LLM Analysis
 async function checkForErrorsAndAnalyze(sources, logTail) {
 for (const source of sources) {
 const prevStatus = previousSourceStatuses[source.id];
 const currentStatus = source.status;
 
 // Check if source just went into error/blocked/hitl state
 if ((currentStatus === 'blocked' || currentStatus === 'error' || currentStatus === 'hitl') 
 && prevStatus !== currentStatus) {
 
 const errorKey = `${source.id}-${currentStatus}-${Date.now().toString().slice(0, -4)}`;
 
 if (!analyzedErrors.has(errorKey)) {
 analyzedErrors.add(errorKey);
 
 // Get relevant log lines for this source
 const relevantLogs = logTail
 .filter(line => line.toLowerCase().includes(source.id.toLowerCase()) || 
 line.toLowerCase().includes(source.name?.toLowerCase() || '') ||
 line.includes('error') || line.includes('Error') ||
 line.includes('blocked') || line.includes('403') || line.includes('429'))
 .slice(-20)
 .join('\n');
 
 // Analyze with LLM
 analyzeErrorWithLLM(source, relevantLogs, currentStatus);
 }
 }
 
 // Update tracking
 previousSourceStatuses[source.id] = currentStatus;
 }
 }
 
 async function analyzeErrorWithLLM(source, logContext, errorType) {
 try {
 const response = await fetch(`${API_BASE}/analyze-error`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({
 sourceId: source.id,
 sourceName: source.name,
 sourceUrl: source.url,
 errorType: errorType,
 logContext: logContext,
 pipeline: source.pipeline
 })
 });
 
 if (response.ok) {
 const result = await response.json();
 
 addNotification({
 type: 'error',
 source: source.name,
 sourceId: source.id,
 sourceUrl: source.url,
 message: result.summary || `Source entered ${errorType} state`,
 suggestion: result.suggestion,
 actions: result.actions || [
 { label: ' View PRD', action: `openPrdModal('${source.id}', '${source.name}', '${source.url}')` },
 { label: ' Retry', action: `retrySource('${source.id}')` }
 ]
 });
 } else {
 // Fallback notification without LLM analysis
 addNotification({
 type: 'error',
 source: source.name,
 sourceId: source.id,
 sourceUrl: source.url,
 message: `Source entered ${errorType} state - check logs for details`,
 suggestion: getDefaultSuggestion(errorType),
 actions: [
 { label: ' View PRD', action: `openPrdModal('${source.id}', '${source.name}', '${source.url}')` }
 ]
 });
 }
 } catch (error) {
 console.error('Error analyzing with LLM:', error);
 // Add basic notification without LLM
 addNotification({
 type: 'error',
 source: source.name,
 sourceId: source.id,
 sourceUrl: source.url,
 message: `Source entered ${errorType} state`,
 suggestion: getDefaultSuggestion(errorType)
 });
 }
 }
 
 function getDefaultSuggestion(errorType) {
 const suggestions = {
 'blocked': 'Try increasing delays in PRD (min_delay: 5-10s), enable stealth mode, or rotate proxies.',
 'error': 'Check if website structure changed. May need to update selectors in the extractor.',
 'hitl': 'Human verification needed. Check for CAPTCHA or login requirements.'
 };
 return suggestions[errorType] || 'Review logs and PRD configuration.';
 }
 
 async function retrySource(sourceId) {
 showNotification(` Retrying ${sourceId}...`, 'info');
 try {
 await fetch(`${API_BASE}/source/${sourceId}/retry`, { method: 'POST' });
 showNotification(` Retry initiated for ${sourceId}`, 'success');
 } catch (err) {
 showNotification(` Failed to retry: ${err.message}`, 'error');
 }
 }
 
 // Format numbers with commas
 function formatNumber(num) {
 if (num === null || num === undefined || num === 'null') return '--';
 return parseInt(num).toLocaleString();
 }
 
 // Settings Panel Toggle
 function toggleSettingsPanel() {
 const overlay = document.getElementById('settingsOverlay');
 overlay.classList.toggle('visible');
 }
 
 function closeSettingsPanel() {
 const overlay = document.getElementById('settingsOverlay');
 overlay.classList.remove('visible');
 }
 
 // ============================================
 // Browser Preview Panel (CDP WebSocket)
 // ============================================
 
 let browserWs = null;
 let browserSessionId = null;
 let screencastEnabled = false;
 let browserConnected = false;
 
 function browserLog(message, type = 'info') {
 const log = document.getElementById('browserLog');
 const time = new Date().toLocaleTimeString();
 const typeClass = type === 'error' ? 'browser-log-error' : 
 type === 'success' ? 'browser-log-success' :
 type === 'url' ? 'browser-log-url' : 
 type === 'action' ? 'browser-log-action' : '';
 
 const entry = document.createElement('div');
 entry.className = 'browser-log-entry';
 entry.innerHTML = `<span class="browser-log-time">[${time}]</span><span class="${typeClass}">${message}</span>`;
 log.appendChild(entry);
 log.scrollTop = log.scrollHeight;
 }
 
 function updateBrowserStatus(connected, text) {
 browserConnected = connected;
 const dot = document.getElementById('browserStatusDot');
 const statusText = document.getElementById('browserStatusText');
 dot.className = 'browser-status-dot' + (connected ? ' connected' : '');
 statusText.textContent = text || (connected ? 'Connected' : 'Disconnected');
 }
 
 async function startBrowserSession() {
 browserLog(' Starting browser session...', 'action');
 updateBrowserStatus(false, 'Starting...');
 
 document.getElementById('browserLoading').style.display = 'block';
 document.getElementById('browserPlaceholder').style.display = 'none';
 
 try {
 // Request backend to start Chrome with CDP
 const response = await fetch(`${API_BASE}/browser/start`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' }
 });
 
 const data = await response.json();
 
 if (data.success) {
 browserLog(` Browser started on port ${data.port}`, 'success');
 
 // Try WebSocket connection, fall back to polling mode
 try {
 browserLog(` Attempting WebSocket connection...`, 'action');
 await connectToCDP(data.ws_url);
 } catch (wsError) {
 browserLog(` WebSocket unavailable, using polling mode`, 'action');
 browserConnected = true;
 updateBrowserStatus(true, 'Connected (Polling)');
 document.getElementById('browserLoading').style.display = 'none';
 
 // Start polling for screenshots
 startScreenshotPolling();
 }
 
 document.getElementById('startBrowserBtn').style.display = 'none';
 document.getElementById('stopBrowserBtn').style.display = 'inline-block';
 
 // Auto-navigate to source URL if in PRD modal
 if (currentPrdSource && currentPrdSource.url) {
 const urlBar = document.getElementById('browserUrlBar');
 urlBar.value = currentPrdSource.url;
 setTimeout(() => browserNavigate(), 500);
 }
 } else {
 throw new Error(data.error || 'Failed to start browser');
 }
 } catch (error) {
 browserLog(` Error: ${error.message}`, 'error');
 updateBrowserStatus(false, 'Error');
 document.getElementById('browserLoading').style.display = 'none';
 document.getElementById('browserPlaceholder').style.display = 'block';
 }
 }
 
 async function connectToCDP(wsUrl) {
 return new Promise((resolve, reject) => {
 browserLog(` Connecting to CDP: ${wsUrl}`, 'action');
 
 browserWs = new WebSocket(wsUrl);
 
 browserWs.onopen = () => {
 browserLog(' CDP WebSocket connected', 'success');
 updateBrowserStatus(true, 'Connected');
 document.getElementById('browserLoading').style.display = 'none';
 
 // Enable page events
 sendCDPCommand('Page.enable');
 sendCDPCommand('Runtime.enable');
 sendCDPCommand('DOM.enable');
 
 // Start screencast for live preview
 startScreencast();
 
 resolve();
 };
 
 browserWs.onmessage = (event) => {
 handleCDPMessage(JSON.parse(event.data));
 };
 
 browserWs.onerror = (error) => {
 browserLog(` WebSocket error: ${error?.message || 'Connection failed'}`, 'error');
 browserLog(` This may be due to browser security restrictions on localhost WebSocket connections`, 'error');
 updateBrowserStatus(false, 'Error');
 reject(error);
 };
 
 browserWs.onclose = () => {
 browserLog(' WebSocket disconnected', 'action');
 updateBrowserStatus(false, 'Disconnected');
 browserWs = null;
 screencastEnabled = false;
 };
 });
 }
 
 let cdpCommandId = 1;
 const cdpCallbacks = {};
 
 function sendCDPCommand(method, params = {}) {
 if (!browserWs || browserWs.readyState !== WebSocket.OPEN) {
 browserLog(' Not connected to browser', 'error');
 return Promise.reject(new Error('Not connected'));
 }
 
 const id = cdpCommandId++;
 
 return new Promise((resolve, reject) => {
 cdpCallbacks[id] = { resolve, reject };
 
 browserWs.send(JSON.stringify({
 id,
 method,
 params
 }));
 });
 }
 
 function handleCDPMessage(msg) {
 // Handle command responses
 if (msg.id && cdpCallbacks[msg.id]) {
 if (msg.error) {
 cdpCallbacks[msg.id].reject(new Error(msg.error.message));
 } else {
 cdpCallbacks[msg.id].resolve(msg.result);
 }
 delete cdpCallbacks[msg.id];
 return;
 }
 
 // Handle events
 if (msg.method) {
 switch (msg.method) {
 case 'Page.screencastFrame':
 handleScreencastFrame(msg.params);
 break;
 case 'Page.loadEventFired':
 browserLog(' Page loaded', 'success');
 break;
 case 'Page.frameNavigated':
 if (msg.params.frame.url) {
 document.getElementById('browserUrlBar').value = msg.params.frame.url;
 browserLog(` Navigated to: ${msg.params.frame.url}`, 'url');
 }
 break;
 }
 }
 }
 
 function startScreencast() {
 if (screencastEnabled) return;
 
 sendCDPCommand('Page.startScreencast', {
 format: 'jpeg',
 quality: 60,
 maxWidth: 1200,
 maxHeight: 800,
 everyNthFrame: 2
 }).then(() => {
 screencastEnabled = true;
 browserLog(' Screencast started', 'success');
 }).catch(err => {
 browserLog(` Screencast error: ${err.message}`, 'error');
 });
 }
 
 // Polling-based screenshot mode (fallback when WebSocket fails)
 let screenshotPollingInterval = null;
 
 function startScreenshotPolling() {
 if (screenshotPollingInterval) return;
 
 browserLog(' Starting screenshot polling mode', 'action');
 
 // Take initial screenshot
 takePolledScreenshot();
 
 // Poll every 2 seconds
 screenshotPollingInterval = setInterval(takePolledScreenshot, 2000);
 }
 
 function stopScreenshotPolling() {
 if (screenshotPollingInterval) {
 clearInterval(screenshotPollingInterval);
 screenshotPollingInterval = null;
 }
 }
 
 async function takePolledScreenshot() {
 try {
 const response = await fetch(`${API_BASE}/browser/screenshot`);
 const data = await response.json();
 
 if (data.success && data.screenshot) {
 const img = document.getElementById('browserScreenshot');
 const placeholder = document.getElementById('browserPlaceholder');
 const loading = document.getElementById('browserLoading');
 
 img.src = `data:image/jpeg;base64,${data.screenshot}`;
 img.style.display = 'block';
 placeholder.style.display = 'none';
 loading.style.display = 'none';
 }
 } catch (err) {
 // Silent fail for polling
 }
 }
 
 function handleScreencastFrame(params) {
 const img = document.getElementById('browserScreenshot');
 const placeholder = document.getElementById('browserPlaceholder');
 const loading = document.getElementById('browserLoading');
 
 img.src = 'data:image/jpeg;base64,' + params.data;
 img.style.display = 'block';
 placeholder.style.display = 'none';
 loading.style.display = 'none';
 
 // Acknowledge the frame to continue receiving
 sendCDPCommand('Page.screencastFrameAck', {
 sessionId: params.sessionId
 });
 }
 
 async function stopBrowserSession() {
 browserLog(' Stopping browser session...', 'action');
 
 // Stop screencast if running
 if (screencastEnabled) {
 await sendCDPCommand('Page.stopScreencast').catch(() => {});
 screencastEnabled = false;
 }
 
 // Stop screenshot polling if running
 stopScreenshotPolling();
 
 if (browserWs) {
 browserWs.close();
 browserWs = null;
 }
 
 browserConnected = false;
 
 // Tell backend to stop browser
 try {
 await fetch(`${API_BASE}/browser/stop`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' }
 });
 } catch (e) {
 console.error('Error stopping browser:', e);
 }
 
 updateBrowserStatus(false, 'Stopped');
 document.getElementById('browserScreenshot').style.display = 'none';
 document.getElementById('browserPlaceholder').style.display = 'block';
 document.getElementById('startBrowserBtn').style.display = 'inline-block';
 document.getElementById('stopBrowserBtn').style.display = 'none';
 browserLog(' Browser session stopped', 'success');
 }
 
 async function browserNavigate() {
 const url = document.getElementById('browserUrlBar').value.trim();
 if (!url) return;
 
 // Add protocol if missing
 const fullUrl = url.startsWith('http') ? url : 'https://' + url;
 
 browserLog(` Navigating to: ${fullUrl}`, 'action');
 document.getElementById('browserLoading').style.display = 'block';
 
 try {
 // Try WebSocket first if connected
 if (browserWs && browserWs.readyState === WebSocket.OPEN) {
 await sendCDPCommand('Page.navigate', { url: fullUrl });
 } else {
 // Use API fallback
 const response = await fetch(`${API_BASE}/browser/navigate`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({ url: fullUrl })
 });
 const data = await response.json();
 
 if (data.success) {
 browserLog(` Navigation started`, 'success');
 // Trigger screenshot refresh after navigation
 setTimeout(takePolledScreenshot, 1500);
 } else {
 throw new Error(data.error || 'Navigation failed');
 }
 }
 } catch (error) {
 browserLog(` Navigation error: ${error.message}`, 'error');
 }
 
 document.getElementById('browserLoading').style.display = 'none';
 }
 
 async function browserBack() {
 browserLog('‚Üê Going back', 'action');
 try {
 const history = await sendCDPCommand('Page.getNavigationHistory');
 if (history.currentIndex > 0) {
 await sendCDPCommand('Page.navigateToHistoryEntry', {
 entryId: history.entries[history.currentIndex - 1].id
 });
 }
 } catch (error) {
 browserLog(` Error: ${error.message}`, 'error');
 }
 }
 
 async function browserForward() {
 browserLog('‚Üí Going forward', 'action');
 try {
 const history = await sendCDPCommand('Page.getNavigationHistory');
 if (history.currentIndex < history.entries.length - 1) {
 await sendCDPCommand('Page.navigateToHistoryEntry', {
 entryId: history.entries[history.currentIndex + 1].id
 });
 }
 } catch (error) {
 browserLog(` Error: ${error.message}`, 'error');
 }
 }
 
 async function browserRefresh() {
 browserLog(' Refreshing page', 'action');
 try {
 await sendCDPCommand('Page.reload');
 } catch (error) {
 browserLog(` Error: ${error.message}`, 'error');
 }
 }
 
 async function browserSnapshot() {
 browserLog(' Taking screenshot...', 'action');
 try {
 const result = await sendCDPCommand('Page.captureScreenshot', {
 format: 'png',
 quality: 100
 });
 
 // Create download link
 const link = document.createElement('a');
 link.href = 'data:image/png;base64,' + result.data;
 link.download = `screenshot_${Date.now()}.png`;
 link.click();
 
 browserLog(' Screenshot saved', 'success');
 } catch (error) {
 browserLog(` Error: ${error.message}`, 'error');
 }
 }
 
 async function browserExecuteJS() {
 const js = prompt('Enter JavaScript to execute:');
 if (!js) return;
 
 browserLog(` Executing: ${js.substring(0, 50)}...`, 'action');
 try {
 const result = await sendCDPCommand('Runtime.evaluate', {
 expression: js,
 returnByValue: true
 });
 
 const value = result.result.value;
 browserLog(` Result: ${JSON.stringify(value).substring(0, 200)}`, 'success');
 console.log('JS Result:', value);
 } catch (error) {
 browserLog(` Error: ${error.message}`, 'error');
 }
 }
 
 async function browserExtractDOM() {
 browserLog(' Extracting DOM structure...', 'action');
 try {
 const doc = await sendCDPCommand('DOM.getDocument', { depth: -1 });
 
 // Get outer HTML
 const html = await sendCDPCommand('DOM.getOuterHTML', {
 nodeId: doc.root.nodeId
 });
 
 // Save to file via API
 const response = await fetch(`${API_BASE}/browser/save-dom`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({
 html: html.outerHTML,
 url: document.getElementById('browserUrlBar').value
 })
 });
 
 const data = await response.json();
 browserLog(` DOM saved to: ${data.path}`, 'success');
 } catch (error) {
 browserLog(` Error: ${error.message}`, 'error');
 }
 }
 
 // Close browser panel on Escape
 document.addEventListener('keydown', (e) => {
 if (e.key === 'Escape' && document.getElementById('browserPanel').classList.contains('visible')) {
 closeBrowserPanel();
 }
 });
 
 // ============================================
 // End Browser Preview Panel
 // ============================================
 
 // Close settings on Escape
 document.addEventListener('keydown', (e) => {
 if (e.key === 'Escape' && document.getElementById('settingsOverlay').classList.contains('visible')) {
 closeSettingsPanel();
 }
 });
 
 // Populate sources dropdown for Ralph
 function populateSourcesDropdown(sources) {
 // Populate Ralph source selector
 populateRalphSourceSelector(sources);
 }
 
 // Populate Ralph source selector (multi-select)
 function populateRalphSourceSelector(sources) {
 const select = document.getElementById('ralphSource');
 const currentSelections = Array.from(select.selectedOptions).map(o => o.value);
 
 select.innerHTML = '';
 
 // Sort by status (pending/in_progress first), then by name
 const sortedSources = [...sources].sort((a, b) => {
 const statusOrder = { 'in_progress': 0, 'pending': 1, 'blocked': 2, 'completed': 3 };
 const aOrder = statusOrder[a.status] ?? 99;
 const bOrder = statusOrder[b.status] ?? 99;
 if (aOrder !== bOrder) return aOrder - bOrder;
 return a.name.localeCompare(b.name);
 });
 
 sortedSources.forEach(source => {
 const option = document.createElement('option');
 option.value = source.id;
 const pipeline = source.pipeline || {};
 const urlCount = pipeline.urlsFound || 0;
 const htmlCount = pipeline.htmlScraped || 0;
 const buildCount = pipeline.builds || 0;
 
 // Status indicator
 const statusIcon = {
 'in_progress': '',
 'pending': '‚è≥',
 'blocked': '',
 'completed': ''}[source.status] || '';
 
 const modCount = pipeline.mods || 0;
 option.textContent = `${statusIcon} ${source.name} (URLs:${urlCount} HTML:${htmlCount} Builds:${buildCount} Mods:${modCount})`;
 
 // Restore selection
 if (currentSelections.includes(source.id)) {
 option.selected = true;
 }
 
 select.appendChild(option);
 });
 }
 
 // Start Ralph
 async function startRalph() {
 const iterations = parseInt(document.getElementById('ralphIterations').value) || 25;
 const sourceSelect = document.getElementById('ralphSource');
 const selectedSources = Array.from(sourceSelect.selectedOptions).map(o => o.value).filter(v => v);
 
 const config = {
 iterations: iterations,
 sources: selectedSources
 };
 
 try {
 const response = await fetch(`${API_BASE}/ralph/start`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify(config)
 });
 
 const data = await response.json();
 
 if (data.success) {
 updateRalphUI(true, data.pid);
 } else {
 alert('Failed to start Ralph: ' + (data.error || 'Unknown error'));
 }
 } catch (error) {
 alert('Error starting Ralph: ' + error.message);
 }
 }
 
 // Stop Ralph
 async function stopRalph() {
 try {
 const response = await fetch(`${API_BASE}/ralph/stop`, {
 method: 'POST'
 });
 
 const data = await response.json();
 updateRalphUI(false);
 } catch (error) {
 alert('Error stopping Ralph: ' + error.message);
 }
 }
 
 // Update Ralph UI state
 function updateRalphUI(running, pid = null) {
 const statusDot = document.getElementById('ralphStatusDot');
 const statusDot2 = document.getElementById('ralphStatusDot2');
 const statusText = document.getElementById('ralphStatusText');
 const pidText = document.getElementById('ralphPid');
 const startBtn = document.getElementById('startRalphBtn');
 const stopBtn = document.getElementById('stopRalphBtn');
 
 if (running) {
 statusDot.className = 'status-dot running';
 statusDot2.className = 'scraper-status-dot running';
 statusText.textContent = 'Running';
 pidText.textContent = pid ? `PID: ${pid}` : '';
 startBtn.style.display = 'none';
 stopBtn.style.display = 'flex';
 } else {
 statusDot.className = 'status-dot stopped';
 statusDot2.className = 'scraper-status-dot stopped';
 statusText.textContent = 'Stopped';
 pidText.textContent = '';
 startBtn.style.display = 'flex';
 stopBtn.style.display = 'none';
 }
 }
 
 // Update Ralph status from server
 async function updateRalphStatus() {
 try {
 const response = await fetch(`${API_BASE}/ralph/status`);
 const data = await response.json();
 
 updateRalphUI(data.running, data.pid);
 
 if (data.prd && data.prd.project) {
 document.getElementById('ralphProject').textContent = data.prd.project;
 document.getElementById('ralphStoryProgress').textContent = 
 `Stories: ${data.prd.stories_completed}/${data.prd.stories_total} | Source: ${data.prd.source || 'N/A'}`;
 } else {
 document.getElementById('ralphProject').textContent = 'No active project';
 document.getElementById('ralphStoryProgress').textContent = '--';
 }
 } catch (error) {
 console.error('Failed to fetch Ralph status:', error);
 }
 }
 
 // Log panel expand/collapse
 let logPanelExpanded = false; // Default to collapsed
 
 function toggleLogPanel() {
 logPanelExpanded = !logPanelExpanded;
 const mainGrid = document.getElementById('mainGrid');
 mainGrid.classList.toggle('logs-expanded', logPanelExpanded);
 
 // Save preference
 localStorage.setItem('logPanelExpanded', logPanelExpanded);
 }
 
 // Restore log panel state on load
 function initLogPanel() {
 const saved = localStorage.getItem('logPanelExpanded');
 logPanelExpanded = saved === 'true';
 document.getElementById('mainGrid').classList.toggle('logs-expanded', logPanelExpanded);
 }
 
 // Log refresh controls
 let autoRefreshEnabled = true;
 let autoScrollEnabled = true;
 
 function toggleAutoRefresh() {
 autoRefreshEnabled = !autoRefreshEnabled;
 const btn = document.getElementById('autoRefreshBtn');
 btn.classList.toggle('active', autoRefreshEnabled);
 }
 
 function clearLogDisplay() {
 document.getElementById('logOutput').innerHTML = '<span class="info">Log cleared. Waiting for new data...</span>';
 sourceLogCache = {}; // Clear cache too
 }
 
 // Log Source Pagination Functions
 function updateLogSourceList(sources) {
 // Only show: running agents (in_progress) and sources with errors (blocked)
 const running = sources
 .filter(s => s.status === 'in_progress')
 .sort((a, b) => a.name.localeCompare(b.name));
 
 const errors = sources
 .filter(s => s.status === 'blocked')
 .sort((a, b) => a.name.localeCompare(b.name));
 
 // Combine: All Sources first, then running, then errors
 const activeSources = [...running, ...errors];
 
 if (activeSources.length > 0) {
 logSourceList = [
 { id: '_all', name: 'All Active', status: 'all' },
 ...activeSources
 ];
 } else {
 // No active sources - just show "All" with no pagination
 logSourceList = [
 { id: '_all', name: 'No Active Ralphs', status: 'idle' }
 ];
 }
 
 // Reset to first item if current selection is no longer valid
 if (currentLogSourceIndex >= logSourceList.length) {
 currentLogSourceIndex = 0;
 }
 
 // Update UI
 updateLogSourceUI();
 }
 
 function updateLogSourceUI() {
 const nameEl = document.getElementById('logSourceName');
 const counterEl = document.getElementById('logSourceCounter');
 const statusEl = document.getElementById('logSourceStatus');
 const prevBtn = document.getElementById('logPrevBtn');
 const nextBtn = document.getElementById('logNextBtn');
 
 if (logSourceList.length === 0) {
 nameEl.textContent = 'No Sources';
 counterEl.textContent = '0 of 0';
 statusEl.className = 'log-source-status';
 prevBtn.classList.add('disabled');
 nextBtn.classList.add('disabled');
 return;
 }
 
 // Clamp index
 currentLogSourceIndex = Math.max(0, Math.min(currentLogSourceIndex, logSourceList.length - 1));
 
 const current = logSourceList[currentLogSourceIndex];
 nameEl.textContent = current.name;
 
 // Style based on status
 if (current.status === 'idle') {
 nameEl.className = 'log-source-name';
 nameEl.style.color = 'var(--text-muted)';
 } else if (current.id === '_all') {
 nameEl.className = 'log-source-name all-sources';
 nameEl.style.color = '';
 } else {
 nameEl.className = 'log-source-name';
 nameEl.style.color = '';
 }
 
 // Counter - hide if only 1 item (no active ralphs case)
 if (logSourceList.length <= 1) {
 counterEl.textContent = 'idle';
 counterEl.style.color = 'var(--text-muted)';
 } else {
 counterEl.textContent = `${currentLogSourceIndex + 1} of ${logSourceList.length}`;
 counterEl.style.color = '';
 }
 
 // Status indicator
 if (current.id === '_all' || current.status === 'idle') {
 statusEl.className = 'log-source-status';
 statusEl.style.display = 'none';
 } else {
 statusEl.style.display = 'inline-block';
 statusEl.className = `log-source-status ${current.status === 'in_progress' ? 'running' : current.status}`;
 }
 
 // Arrow states - disable both if only 1 item
 const singleItem = logSourceList.length <= 1;
 prevBtn.classList.toggle('disabled', singleItem || currentLogSourceIndex === 0);
 nextBtn.classList.toggle('disabled', singleItem || currentLogSourceIndex >= logSourceList.length - 1);
 }
 
 function prevLogSource() {
 if (currentLogSourceIndex > 0) {
 currentLogSourceIndex--;
 updateLogSourceUI();
 refreshLogNow();
 }
 }
 
 function nextLogSource() {
 if (currentLogSourceIndex < logSourceList.length - 1) {
 currentLogSourceIndex++;
 updateLogSourceUI();
 refreshLogNow();
 }
 }
 
 function filterLogBySource(logText, sourceId) {
 if (sourceId === '_all' || !sourceId) {
 return logText;
 }
 
 // Filter log lines that mention this source
 const lines = logText.split('\n');
 const sourcePatterns = [
 sourceId.toLowerCase(),
 sourceId.replace(/_/g, '-').toLowerCase(),
 sourceId.replace(/-/g, '_').toLowerCase()
 ];
 
 // Also look for common log patterns with source context
 const filteredLines = lines.filter(line => {
 const lineLower = line.toLowerCase();
 return sourcePatterns.some(pattern => lineLower.includes(pattern)) ||
 lineLower.includes('ralph') || // Keep ralph system messages
 lineLower.includes('iteration') || // Keep iteration markers
 lineLower.includes('stage') || // Keep stage markers
 /^\s*[-=]+\s*$/.test(line); // Keep separator lines
 });
 
 if (filteredLines.length === 0) {
 return `No recent log entries for ${sourceId}\n\n(Showing system messages only)`;
 }
 
 return filteredLines.join('\n');
 }
 
 let killCheckInterval = null;
 
 async function killAllRalphs() {
 const btn = document.getElementById('killAllBtn');
 const originalText = btn.innerHTML;
 
 btn.classList.add('killing');
 btn.innerHTML = ' Killing...';
 
 // Add message to log
 const logOutput = document.getElementById('logOutput');
 const killMsg = document.createElement('div');
 killMsg.innerHTML = `<span class="error">[${new Date().toLocaleTimeString()}] KILL ALL initiated...</span>`;
 logOutput.appendChild(killMsg);
 logOutput.scrollTop = logOutput.scrollHeight;
 
 try {
 const response = await fetch(`${API_BASE}/ralph/kill-all`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' }
 });
 const data = await response.json();
 
 if (data.success) {
 // Start polling to verify all processes are dead
 btn.innerHTML = ' Verifying...';
 verifyAllKilled(btn, originalText);
 } else {
 throw new Error(data.error || 'Unknown error');
 }
 } catch (error) {
 console.error('Kill all failed:', error);
 btn.innerHTML = ' Failed - Retry';
 // Keep killing class so it stays red - user can click again
 }
 }
 
 async function verifyAllKilled(btn, originalText) {
 let attempts = 0;
 const maxAttempts = 20; // 10 seconds max
 
 // Clear any existing interval
 if (killCheckInterval) clearInterval(killCheckInterval);
 
 killCheckInterval = setInterval(async () => {
 attempts++;
 
 try {
 const response = await fetch(`${API_BASE}/ralph/status`);
 const data = await response.json();
 
 if (!data.running) {
 // All processes confirmed dead
 clearInterval(killCheckInterval);
 killCheckInterval = null;
 
 btn.innerHTML = ' All Dead';
 btn.classList.remove('killing');
 btn.classList.add('killed-success');
 
 const logOutput = document.getElementById('logOutput');
 const doneMsg = document.createElement('div');
 doneMsg.innerHTML = `<span class="success">[${new Date().toLocaleTimeString()}] All Ralph processes terminated</span>`;
 logOutput.appendChild(doneMsg);
 logOutput.scrollTop = logOutput.scrollHeight;
 
 // Reset button after brief success indication
 setTimeout(() => {
 btn.classList.remove('killed-success');
 btn.innerHTML = originalText;
 }, 2000);
 
 // Refresh dashboard
 updateDashboard();
 } else if (attempts >= maxAttempts) {
 // Timeout - some processes may still be running
 clearInterval(killCheckInterval);
 killCheckInterval = null;
 
 btn.innerHTML = ' Check Manually';
 setTimeout(() => {
 btn.classList.remove('killing');
 btn.innerHTML = originalText;
 }, 3000);
 } else {
 // Still killing - update status
 btn.innerHTML = ` Killing... (${attempts})`;
 }
 } catch (error) {
 // API error - keep trying
 console.error('Status check failed:', error);
 }
 }, 500); // Check every 500ms
 }
 
async function refreshLogNow() {
  try {
   const response = await fetch(`${API_BASE}/log/fresh?lines=200`);
   const data = await response.json();
   
   if (data.log) {
    const logOutput = document.getElementById('logOutput');
    
    // Get current selected source
    const currentSource = logSourceList[currentLogSourceIndex];
    const sourceId = currentSource ? currentSource.id : '_all';
    
    // Filter log if a specific source is selected
    let displayLog = data.log;
    if (sourceId !== '_all') {
     displayLog = filterLogBySource(data.log, sourceId);
    }
    
    logOutput.innerHTML = colorizeLog(displayLog);
    if (autoScrollEnabled) {
     logOutput.scrollTop = logOutput.scrollHeight;
    }
    
    const sourceLabel = sourceId === '_all' ? 'All' : currentSource.name;
    document.getElementById('logRefresh').textContent = `${sourceLabel} ¬∑ ${new Date().toLocaleTimeString()}`;
   }
  } catch (error) {
   console.error('Failed to refresh log:', error);
  }
 }
 
 // Generate PRD using browser analysis
 async function generatePRD() {
 const sourceSelect = document.getElementById('ralphSource');
 const selectedSources = Array.from(sourceSelect.selectedOptions).map(o => o.value).filter(v => v);
 
 if (selectedSources.length === 0) {
 alert('Please select a source first');
 return;
 }
 
 if (selectedSources.length > 1) {
 alert('Please select only one source for PRD generation');
 return;
 }
 
 const sourceId = selectedSources[0];
 const source = allSources.find(s => s.id === sourceId);
 
 if (!source) {
 alert('Source not found');
 return;
 }
 
 // Show status
 const statusDiv = document.getElementById('prdGenStatus');
 const statusText = document.getElementById('prdGenStatusText');
 statusDiv.style.display = 'block';
 statusText.textContent = `Analyzing ${source.name}...`;
 
 try {
 const response = await fetch(`${API_BASE}/prd/generate`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({
 sourceId: sourceId,
 url: source.url,
 name: source.name,
 useBrowser: true
 })
 });
 
 const data = await response.json();
 
 if (data.success) {
 statusText.innerHTML = `<span class="success"> PRD generated for ${source.name}</span>`;
 setTimeout(() => {
 statusDiv.style.display = 'none';
 updateRalphStatus();
 }, 3000);
 } else {
 statusText.innerHTML = `<span class="error"> ${data.error || 'Failed to generate PRD'}</span>`;
 }
 } catch (error) {
 statusText.innerHTML = `<span class="error"> Error: ${error.message}</span>`;
 }
 }
 
 // ANSI color code to CSS class mapping
 const ANSI_COLORS = {
 '30': 'color: #1a1a2e', // black
 '31': 'color: #ff6b6b', // red
 '32': 'color: #4ade80', // green
 '33': 'color: #fbbf24', // yellow
 '34': 'color: #60a5fa', // blue
 '35': 'color: #c084fc', // magenta
 '36': 'color: #22d3ee', // cyan
 '37': 'color: #e5e5e5', // white
 '90': 'color: #6b7280', // bright black (gray)
 '91': 'color: #f87171', // bright red
 '92': 'color: #4ade80', // bright green
 '93': 'color: #facc15', // bright yellow
 '94': 'color: #93c5fd', // bright blue
 '95': 'color: #e879f9', // bright magenta
 '96': 'color: #67e8f9', // bright cyan
 '97': 'color: #ffffff', // bright white
 };

 // Convert ANSI escape codes to HTML spans
 function ansiToHtml(text) {
 // Handle both \x1b[ and raw [0; patterns
 let result = text;
 let openSpans = 0;

 // Match ANSI escape sequences: \x1b[...m or \033[...m or raw [digits;digitsm patterns
 result = result.replace(/\x1b\[([0-9;]*)m|\[([0-9]+;?[0-9]*)m/g, (match, p1, p2) => {
 const codes = (p1 || p2 || '').split(';').filter(c => c);

 // Reset code
 if (codes.length === 0 || codes.includes('0')) {
 const closeSpans = '</span>'.repeat(openSpans);
 openSpans = 0;
 return closeSpans;
 }

 // Build style from codes
 let styles = [];
 for (const code of codes) {
 if (code === '1') styles.push('font-weight: bold');
 else if (code === '2') styles.push('opacity: 0.7');
 else if (code === '3') styles.push('font-style: italic');
 else if (code === '4') styles.push('text-decoration: underline');
 else if (ANSI_COLORS[code]) styles.push(ANSI_COLORS[code]);
 }

 if (styles.length > 0) {
 openSpans++;
 return `<span style="${styles.join('; ')}">`;
 }
 return '';
 });

 // Close any remaining open spans
 result += '</span>'.repeat(openSpans);

 return result;
 }

 // Colorize log output
 function colorizeLog(text) {
 // First convert ANSI codes to HTML
 let result = ansiToHtml(text);

 // Then apply keyword highlighting (only if not already colored by ANSI)
 return result
 .replace(/||SUCCESS|COMPLETE/gi, '<span class="success">$&</span>')
 .replace(/|ERROR|FAIL|BLOCKED/gi, '<span class="error">$&</span>')
 .replace(/|WARNING|WARN/gi, '<span class="warning">$&</span>')
 .replace(/‚Ñπ|INFO|‚Üí/gi, '<span class="info">$&</span>')
 .replace(/(Stage \d)/gi, '<span class="info">$1</span>')
 .replace(/(\d+\/\d+)/g, '<span class="success">$1</span>');
 }
 
// Update dashboard
 async function updateDashboard() {
  try {
   if (isInitialLoad) updateLoadingStatus('Fetching data...');
   
   const response = await fetch(`${API_BASE}/status`);
   const data = await response.json();
   
   // Update status
   const statusDot = document.getElementById('statusDot');
   const statusText = document.getElementById('statusText');
   if (data.running) {
    statusDot.className = 'status-dot running';
    statusText.textContent = 'Running';
   } else {
    statusDot.className = 'status-dot stopped';
    statusText.textContent = 'Stopped';
   }
   
   // Update stats
   document.getElementById('totalSources').textContent = data.sources.total;
   document.getElementById('completedSources').textContent = data.sources.completed;
   document.getElementById('inProgressSources').textContent = data.sources.in_progress;
   
   // Update pipeline stages
   let totalUrls = 0;
   if (data.all_sources && data.all_sources.length > 0) {
    data.all_sources.forEach(source => {
     const pipeline = source.pipeline || {};
     totalUrls += pipeline.urlsFound || 0;
    });
   }
   
   const totalHtml = data.html_files || 0;
   const totalBuilds = data.total_builds || data.builds || 0;
   const totalMods = data.total_mods || data.mods || 0;
   
   updateStage('stage1', totalUrls, null);
   updateStage('stage2', totalHtml, totalUrls);
   updateStage('stage3', totalBuilds, null);
   updateStage('stage4', totalMods, null);
   
   // Update sources list
   updateSourcesList(data.all_sources || []);
   
   // Populate Ralph source selector
   if (data.all_sources) {
    allSources = data.all_sources;
    populateSourcesDropdown(data.all_sources);
    updateLogSourceList(data.all_sources);
    
    // Check for errors
    checkForErrorsAndAnalyze(data.all_sources, data.log_tail || []);
   }
   
   // Update log
   if (autoRefreshEnabled) {
    refreshLogNow();
   }
   
   // Update Ralph status
   updateRalphStatus();
   
   // Update refresh times
   const now = new Date().toLocaleTimeString();
   document.getElementById('sourcesRefreshText').textContent = `Live ¬∑ ${now}`;
   document.getElementById('sourcesLiveDot').className = 'live-dot';
   
   // Hide loading screen on first successful load
   if (isInitialLoad) {
    isInitialLoad = false;
    hideLoadingScreen();
   }
   
  } catch (error) {
   console.error('Failed to fetch status:', error);
   
   document.getElementById('statusDot').className = 'status-dot stopped';
   document.getElementById('statusText').textContent = 'API Offline';
   document.getElementById('sourcesLiveDot').className = 'live-dot error';
   document.getElementById('sourcesRefreshText').textContent = 'Offline';
   
   // Hide loading after timeout so UI is usable
   if (isInitialLoad) {
    updateLoadingStatus('Connecting...');
    setTimeout(() => {
     if (isInitialLoad) {
      isInitialLoad = false;
      hideLoadingScreen();
     }
    }, 3000);
   }
  }
 }
 
 function updateStage(id, current, total) {
 const stage = document.getElementById(id);
 const valueEl = stage.querySelector('.header-stage-value');
 
 if (current !== null && current !== undefined && current !== 'null') {
 valueEl.textContent = formatNumber(current);
 if (total && current >= total) {
 stage.className = 'header-stage complete';
 } else if (current > 0) {
 stage.className = 'header-stage active';
 } else {
 stage.className = 'header-stage';
 }
 } else {
 valueEl.textContent = '--';
 stage.className = 'header-stage';
 }
 }
 
 // Sources state for filtering/sorting
 let allSourcesData = [];
 let currentFilter = '';
 let currentSort = 'progress';
 
// Initialize filter and sort event listeners with debouncing
 const debouncedFilter = debounce((value) => {
  currentFilter = value.toLowerCase();
  renderSourcesList();
 }, 150);
 
 document.getElementById('sourcesFilter').addEventListener('input', (e) => {
  debouncedFilter(e.target.value);
 });
 
 document.getElementById('sourcesSort').addEventListener('change', (e) => {
  currentSort = e.target.value;
  renderSourcesList();
 });
 
function updateSourcesList(sources) {
  allSourcesData = sources;
  renderSourcesList();
 }
 
 function renderSourcesList() {
 const container = document.getElementById('sourcesList');
 
 // Filter sources
 let filtered = allSourcesData.filter(source => {
 if (!currentFilter) return true;
 return source.name.toLowerCase().includes(currentFilter) ||
 (source.id && source.id.toLowerCase().includes(currentFilter));
 });
 
 // Sort sources
 filtered.sort((a, b) => {
 const pipeA = a.pipeline || {};
 const pipeB = b.pipeline || {};
 
 switch (currentSort) {
 case 'name':
 return a.name.localeCompare(b.name);
 case 'urls':
 return (pipeB.urlsFound || 0) - (pipeA.urlsFound || 0);
 case 'html':
 return (pipeB.htmlScraped || 0) - (pipeA.htmlScraped || 0);
 case 'builds':
 return (pipeB.builds || 0) - (pipeA.builds || 0);
 case 'progress':
 const progA = pipeA.urlsFound ? (pipeA.htmlScraped || 0) / pipeA.urlsFound : 0;
 const progB = pipeB.urlsFound ? (pipeB.htmlScraped || 0) / pipeB.urlsFound : 0;
 return progB - progA;
 case 'status':
 default:
 const order = { in_progress: 0, pending: 1, blocked: 2, completed: 3 };
 const diff = (order[a.status] || 99) - (order[b.status] || 99);
 if (diff !== 0) return diff;
 return a.name.localeCompare(b.name);
 }
 });
 
// Render sources with lazy loading (show first 30, load more on scroll)
 if (filtered.length === 0) {
  container.innerHTML = `<div class="no-results">No sources matching "${currentFilter}"</div>`;
  return;
 }
 
 const BATCH_SIZE = 30;
 const visibleSources = filtered.slice(0, BATCH_SIZE);
 const hasMore = filtered.length > BATCH_SIZE;
 
 container.innerHTML = visibleSources.map(source => renderSourceItem(source)).join('') +
  (hasMore ? `<div class="load-more" onclick="loadMoreSources()">Load ${filtered.length - BATCH_SIZE} more...</div>` : '');
 
 // Store filtered for load more
 window._filteredSources = filtered;
 window._loadedCount = BATCH_SIZE;
 }
 
 function renderSourceItem(source) {
 const pipeline = source.pipeline || {};
 const progress = pipeline.urlsFound ? 
  Math.round((pipeline.htmlScraped || 0) / pipeline.urlsFound * 100) : 0;
 
 return `
  <div class="source-item" data-source-id="${source.id}"
   onclick="openPrdModal('${source.id}', '${source.name.replace(/'/g, "\\'")}', '${(source.url || '').replace(/'/g, "\\'")}')"
   title="Click to view PRD for ${source.name}">
   <div class="source-info">
    <div class="source-status ${source.status}" 
     data-source-id="${source.id}"
     data-source-name="${source.name}"
     data-source-url="${source.url || ''}"
     data-source-status="${source.status}"
     onclick="event.stopPropagation(); showSourceMenu(event, this)"
     title="Click for actions"></div>
    <div>
     <div class="source-name">${source.name}</div>
     <div class="source-stats">
      URLs: ${formatNumber(pipeline.urlsFound)} | 
      HTML: ${formatNumber(pipeline.htmlScraped)} |
      Builds: ${formatNumber(pipeline.builds)} |
      Mods: ${formatNumber(pipeline.mods)}
     </div>
    </div>
   </div>
   <div class="progress-bar">
    <div class="progress-bar-fill" style="width: ${progress}%"></div>
   </div>
  </div>
 `;
 }
 
 function loadMoreSources() {
 const container = document.getElementById('sourcesList');
 const filtered = window._filteredSources || [];
 const loaded = window._loadedCount || 30;
 const BATCH_SIZE = 30;
 
 const nextBatch = filtered.slice(loaded, loaded + BATCH_SIZE);
 const hasMore = filtered.length > loaded + BATCH_SIZE;
 
 // Remove load more button
 const loadMoreBtn = container.querySelector('.load-more');
 if (loadMoreBtn) loadMoreBtn.remove();
 
 // Append new items
 container.insertAdjacentHTML('beforeend', 
  nextBatch.map(source => renderSourceItem(source)).join('') +
  (hasMore ? `<div class="load-more" onclick="loadMoreSources()">Load ${filtered.length - loaded - BATCH_SIZE} more...</div>` : '')
 );
 
 window._loadedCount = loaded + BATCH_SIZE;
 }
 
 // Initial load and start refresh
 initLogPanel();
 updateLoadingStatus('Initializing...');
 updateDashboard();
 setInterval(updateDashboard, REFRESH_INTERVAL);
 
 // ==========================================
 // Source Action Menu
 // ==========================================
 
 let activeSourceMenu = null;
 
 function showSourceMenu(event, element) {
 event.stopPropagation();
 
 const sourceId = element.dataset.sourceId;
 const sourceName = element.dataset.sourceName;
 const sourceUrl = element.dataset.sourceUrl;
 const sourceStatus = element.dataset.sourceStatus;
 
 const menu = document.getElementById('sourceActionMenu');
 activeSourceMenu = { id: sourceId, name: sourceName, url: sourceUrl, status: sourceStatus };
 
 // Update menu content
 document.getElementById('menuSourceName').textContent = sourceName;
 document.getElementById('menuSourceUrl').textContent = sourceUrl || 'No URL';
 
 // Show/hide actions based on status
 const startBtn = document.getElementById('menuStartRalph');
 const stopBtn = document.getElementById('menuStopRalph');
 const generateBtn = document.getElementById('menuGeneratePrd');
 
 // Check if Ralph is currently running
 const statusText = document.getElementById('statusText')?.textContent || '';
 const ralphRunning = statusText.toLowerCase().includes('running');
 const isCurrentSource = sourceStatus === 'in_progress';
 
 // Always enable both buttons - let the action handle the state
 startBtn.classList.remove('disabled');
 stopBtn.classList.remove('disabled');
 
 if (ralphRunning && isCurrentSource) {
 // This source is currently running - highlight stop
 startBtn.querySelector('.label').textContent = 'Restart Ralph';
 stopBtn.querySelector('.label').textContent = '‚èπ Stop Ralph (running)';
 } else if (ralphRunning) {
 // Ralph is running on a different source
 startBtn.querySelector('.label').textContent = 'Start Ralph';
 stopBtn.querySelector('.label').textContent = '‚èπ Stop Ralph (running)';
 } else {
 // Ralph not running
 startBtn.querySelector('.label').textContent = 'Start Ralph';
 stopBtn.querySelector('.label').textContent = 'Stop Ralph';
 }
 
 // Position menu near the clicked element
 const rect = element.getBoundingClientRect();
 menu.style.left = `${rect.left + 20}px`;
 menu.style.top = `${rect.top - 10}px`;
 
 // Ensure menu stays within viewport
 const menuRect = menu.getBoundingClientRect();
 if (menuRect.right > window.innerWidth) {
 menu.style.left = `${window.innerWidth - 220}px`;
 }
 if (menuRect.bottom > window.innerHeight) {
 menu.style.top = `${rect.top - menuRect.height - 10}px`;
 }
 
 menu.classList.add('visible');
 }
 
 function hideSourceMenu() {
 const menu = document.getElementById('sourceActionMenu');
 menu.classList.remove('visible');
 activeSourceMenu = null;
 }
 
 // Close menus when clicking outside
 document.addEventListener('click', (e) => {
 if (!e.target.closest('.source-action-menu') && !e.target.closest('.source-status')) {
 hideSourceMenu();
 }
 if (!e.target.closest('.notif-container')) {
 closeNotifications();
 }
 });
 
 // Close menus on escape
 document.addEventListener('keydown', (e) => {
 if (e.key === 'Escape') {
 hideSourceMenu();
 closeNotifications();
 }
 });
 
 async function startRalphForSource() {
 if (!activeSourceMenu) return;
 
 const { id, name, url } = activeSourceMenu;
 hideSourceMenu();
 
 // Show loading state
 showNotification(` Starting Ralph for ${name}...`, 'info');
 
 try {
 // Start Ralph with the selected source
 const response = await fetch(`${API_BASE}/ralph/start`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({
 iterations: 25,
 sources: [id]
 })
 });
 
 const data = await response.json();
 
 if (data.success) {
 showNotification(` Ralph started for ${name}`, 'success');
 // Refresh dashboard to show new state
 setTimeout(updateDashboard, 1000);
 } else {
 showNotification(` Failed: ${data.error}`, 'error');
 }
 } catch (err) {
 showNotification(` Error: ${err.message}`, 'error');
 }
 }
 
 async function stopRalph() {
 hideSourceMenu();
 
 showNotification(' Stopping Ralph...', 'info');
 
 try {
 // First try normal stop
 const response = await fetch(`${API_BASE}/ralph/stop`, {
 method: 'POST'
 });
 
 const data = await response.json();
 
 if (data.success) {
 showNotification(` ${data.message || 'Ralph stopped'}`, 'success');
 setTimeout(updateDashboard, 1000);
 } else {
 // If normal stop fails, try kill-all
 showNotification(' Trying force stop...', 'info');
 const killResponse = await fetch(`${API_BASE}/ralph/kill-all`, {
 method: 'POST'
 });
 const killData = await killResponse.json();
 
 if (killData.success) {
 showNotification(` ${killData.message || 'Processes killed'}`, 'success');
 setTimeout(updateDashboard, 1000);
 } else {
 showNotification(` Failed: ${killData.error || 'Unknown error'}`, 'error');
 }
 }
 } catch (err) {
 showNotification(` Error: ${err.message}`, 'error');
 }
 }
 
 async function generatePrdForSource() {
 if (!activeSourceMenu) return;
 
 const { id, name, url } = activeSourceMenu;
 hideSourceMenu();
 
 // Open the PRD editor modal
 openPrdModal(id, name, url);
 }
 
 function viewSourceData() {
 if (!activeSourceMenu) return;
 
 const { id, url } = activeSourceMenu;
 hideSourceMenu();
 
 // Open source URL in new tab
 if (url) {
 window.open(url, '_blank');
 }
 }
 
 // Notification system
 function showNotification(message, type = 'info') {
 const existing = document.querySelector('.notification');
 if (existing) existing.remove();
 
 const notification = document.createElement('div');
 notification.className = `notification ${type}`;
 notification.innerHTML = message;
 document.body.appendChild(notification);
 
 setTimeout(() => notification.classList.add('visible'), 10);
 setTimeout(() => {
 notification.classList.remove('visible');
 setTimeout(() => notification.remove(), 300);
 }, 4000);
 }
 </script>
 
 <!-- Settings Panel -->
 <div id="settingsOverlay" class="settings-overlay" onclick="if(event.target === this) closeSettingsPanel()">
 <div class="settings-panel">
 <div class="settings-header">
 <h2> Settings</h2>
 <button class="settings-close" onclick="closeSettingsPanel()">√ó</button>
 </div>
 <div class="settings-content">
 <!-- Ralph Loop Section -->
 <div class="settings-section">
 <div class="settings-section-title"> Ralph Loop Configuration</div>
 
 <!-- Status Bar -->
 <div class="ralph-status" style="margin-bottom: 16px;">
 <div class="ralph-status-indicator">
 <div class="scraper-status-dot" id="ralphStatusDot2"></div>
 </div>
 <div class="ralph-info">
 <div class="project-name" id="ralphProject">No active project</div>
 <div class="story-progress" id="ralphStoryProgress">--</div>
 </div>
 <div class="status-badge" style="padding: 4px 12px; margin-left: auto;">
 <div class="status-dot" id="ralphStatusDot"></div>
 <span id="ralphStatusText" style="font-size: 11px;">Checking...</span>
 </div>
 </div>
 
 <!-- Source Selection -->
 <div class="form-group" style="margin-bottom: 16px;">
 <label>Target Source(s)</label>
 <select id="ralphSource" multiple size="6" style="width: 100%;">
 <option value="">Loading sources...</option>
 </select>
 <span class="help-text">Hold Ctrl/Cmd to select multiple. Leave empty to use current PRD.</span>
 </div>
 
 <!-- Iterations Config -->
 <div class="iterations-input" style="margin-bottom: 16px;">
 <label>Max Iterations:</label>
 <input type="number" id="ralphIterations" value="25" min="1" max="100">
 <span class="help-text">Ralph will stop after this many iterations</span>
 </div>
 
 <!-- Action Buttons -->
 <div class="btn-group" style="flex-wrap: wrap; gap: 8px;">
 <button class="btn btn-secondary" onclick="generatePRD()" title="Use browser to analyze site and generate PRD">
 Generate PRD
 </button>
 <button class="btn btn-primary" id="startRalphBtn" onclick="startRalph()" style="background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));">
 Start Ralph
 </button>
 <button class="btn btn-danger" id="stopRalphBtn" onclick="stopRalph()" style="display: none;">
 ‚èπ Stop Ralph
 </button>
 </div>
 
 <!-- PRD Generation Status -->
 <div id="prdGenStatus" style="display: none; margin-top: 16px; padding: 12px; background: var(--bg-primary); border-radius: 8px;">
 <div style="display: flex; align-items: center; gap: 8px;">
 <div class="scraper-status-dot running"></div>
 <span id="prdGenStatusText">Analyzing site...</span>
 </div>
 </div>
 </div>
 </div>
 </div>
 </div>
 
 <!-- Source Action Menu -->
 <div id="sourceActionMenu" class="source-action-menu">
 <div class="source-action-menu-header">
 <div class="name" id="menuSourceName">Source Name</div>
 <div class="url" id="menuSourceUrl">https://example.com</div>
 </div>
 <div class="source-action-item start" id="menuStartRalph" onclick="startRalphForSource()">
 <span class="icon"></span>
 <span class="label">Start Ralph</span>
 </div>
 <div class="source-action-item stop" id="menuStopRalph" onclick="stopRalph()">
 <span class="icon">‚èπ</span>
 <span class="label">Stop Ralph</span>
 </div>
 <div class="source-action-divider"></div>
 <div class="source-action-item generate" id="menuGeneratePrd" onclick="generatePrdForSource()">
 <span class="icon"></span>
 <span class="label">Generate PRD</span>
 </div>
 <div class="source-action-item view" onclick="viewSourceData()">
 <span class="icon"></span>
 <span class="label">Visit Website</span>
 </div>
 </div>
 
 <style>
 .notification {
 position: fixed;
 bottom: 24px;
 left: 50%;
 transform: translateX(-50%) translateY(20px);
 padding: 12px 24px;
 background: var(--bg-card);
 border: 1px solid var(--border);
 border-radius: 12px;
 font-size: 14px;
 box-shadow: 0 10px 40px rgba(0,0,0,0.4);
 opacity: 0;
 transition: all 0.3s ease;
 z-index: 2000;
 }
 
 .notification.visible {
 opacity: 1;
 transform: translateX(-50%) translateY(0);
 }
 
 .notification.success { border-color: var(--accent-green); }
 .notification.error { border-color: var(--accent-red); }
 .notification.info { border-color: var(--accent-cyan); }
 
 /* PRD Editor Modal */
 .prd-modal-overlay {
 position: fixed;
 inset: 0;
 background: rgba(0, 0, 0, 0.8);
 backdrop-filter: blur(4px);
 z-index: 3000;
 display: none;
 align-items: center;
 justify-content: center;
 padding: 24px;
 }
 
 .prd-modal-overlay.visible {
 display: flex;
 animation: fadeIn 0.2s ease-out;
 }
 
 @keyframes fadeIn {
 from { opacity: 0; }
 to { opacity: 1; }
 }
 
 .prd-modal {
 background: var(--bg-card);
 border: 1px solid var(--border);
 border-radius: 16px;
 width: 100%;
 max-width: 1200px;
 max-height: 90vh;
 display: flex;
 flex-direction: column;
 animation: modalSlide 0.3s ease-out;
 }
 
 @keyframes modalSlide {
 from { opacity: 0; transform: translateY(-20px) scale(0.95); }
 to { opacity: 1; transform: translateY(0) scale(1); }
 }
 
 .prd-modal-header {
 padding: 20px 24px;
 border-bottom: 1px solid var(--border);
 display: flex;
 align-items: center;
 justify-content: space-between;
 }
 
 .prd-modal-header h2 {
 font-size: 18px;
 font-weight: 600;
 display: flex;
 align-items: center;
 gap: 10px;
 }
 
 .prd-modal-header .source-badge {
 background: var(--bg-secondary);
 padding: 4px 12px;
 border-radius: 20px;
 font-size: 12px;
 color: var(--accent-cyan);
 font-family: 'JetBrains Mono', monospace;
 }
 
 .prd-modal-close {
 width: 32px;
 height: 32px;
 border: none;
 background: var(--bg-secondary);
 border-radius: 8px;
 color: var(--text-muted);
 cursor: pointer;
 font-size: 18px;
 transition: all 0.2s;
 }
 
 .prd-modal-close:hover {
 background: var(--accent-red);
 color: white;
 }
 
 .prd-modal-body {
 display: grid;
 grid-template-columns: 280px 1fr;
 flex: 1;
 overflow: hidden;
 }
 
 .prd-sidebar {
 border-right: 1px solid var(--border);
 padding: 20px;
 overflow-y: auto;
 background: var(--bg-secondary);
 }
 
 .prd-sidebar h3 {
 font-size: 11px;
 text-transform: uppercase;
 letter-spacing: 1px;
 color: var(--text-muted);
 margin-bottom: 12px;
 }
 
 .prd-variables {
 display: flex;
 flex-direction: column;
 gap: 12px;
 }
 
 .prd-variable {
 display: flex;
 flex-direction: column;
 gap: 4px;
 }
 
 .prd-variable label {
 font-size: 12px;
 color: var(--text-secondary);
 font-family: 'JetBrains Mono', monospace;
 }
 
 .prd-variable input, .prd-variable select {
 padding: 8px 12px;
 background: var(--bg-primary);
 border: 1px solid var(--border);
 border-radius: 6px;
 color: var(--text-primary);
 font-size: 13px;
 font-family: 'JetBrains Mono', monospace;
 }
 
 .prd-variable input:focus, .prd-variable select:focus {
 outline: none;
 border-color: var(--accent-cyan);
 }
 
 .prd-actions-sidebar {
 margin-top: 20px;
 padding-top: 20px;
 border-top: 1px solid var(--border);
 display: flex;
 flex-direction: column;
 gap: 8px;
 }
 
 .prd-action-btn {
 padding: 10px 16px;
 border: 1px solid var(--border);
 background: var(--bg-primary);
 border-radius: 8px;
 color: var(--text-primary);
 font-size: 13px;
 cursor: pointer;
 display: flex;
 align-items: center;
 gap: 8px;
 transition: all 0.2s;
 }
 
 .prd-action-btn:hover {
 border-color: var(--accent-cyan);
 background: var(--bg-card);
 }
 
 .prd-action-btn.primary {
 background: var(--accent-cyan);
 border-color: var(--accent-cyan);
 color: black;
 font-weight: 600;
 }
 
 .prd-action-btn.primary:hover {
 background: #1cb5cc;
 }
 
 .prd-action-btn.danger {
 color: var(--accent-red);
 }
 
 .prd-action-btn.danger:hover {
 background: var(--accent-red);
 border-color: var(--accent-red);
 color: white;
 }
 
 .prd-main {
 display: flex;
 flex-direction: column;
 overflow: hidden;
 }
 
 .prd-tabs {
 display: flex;
 border-bottom: 1px solid var(--border);
 padding: 0 20px;
 background: var(--bg-secondary);
 }
 
 .prd-tab {
 padding: 12px 20px;
 border: none;
 background: none;
 color: var(--text-muted);
 font-size: 13px;
 cursor: pointer;
 border-bottom: 2px solid transparent;
 margin-bottom: -1px;
 transition: all 0.2s;
 }
 
 .prd-tab:hover {
 color: var(--text-primary);
 }
 
 .prd-tab.active {
 color: var(--accent-cyan);
 border-bottom-color: var(--accent-cyan);
 }
 
 .prd-content {
 flex: 1;
 overflow: hidden;
 position: relative;
 }
 
 .prd-panel {
 position: absolute;
 inset: 0;
 padding: 20px;
 overflow-y: auto;
 display: none;
 }
 
 .prd-panel.active {
 display: block;
 }
 
 .prd-editor {
 width: 100%;
 height: 100%;
 min-height: 400px;
 background: var(--bg-primary);
 border: 1px solid var(--border);
 border-radius: 8px;
 padding: 16px;
 color: var(--text-primary);
 font-family: 'JetBrains Mono', monospace;
 font-size: 13px;
 line-height: 1.6;
 resize: none;
 }
 
 .prd-editor:focus {
 outline: none;
 border-color: var(--accent-cyan);
 }
 
 .prd-stream {
 background: var(--bg-primary);
 border: 1px solid var(--border);
 border-radius: 8px;
 padding: 16px;
 font-family: 'JetBrains Mono', monospace;
 font-size: 13px;
 line-height: 1.6;
 white-space: pre-wrap;
 min-height: 400px;
 position: relative;
 }
 
 .prd-stream .cursor {
 display: inline-block;
 width: 8px;
 height: 16px;
 background: var(--accent-cyan);
 animation: blink 1s infinite;
 vertical-align: middle;
 margin-left: 2px;
 }
 
 @keyframes blink {
 0%, 50% { opacity: 1; }
 51%, 100% { opacity: 0; }
 }
 
 .prd-stream-status {
 position: absolute;
 top: 12px;
 right: 12px;
 display: flex;
 align-items: center;
 gap: 8px;
 font-size: 11px;
 color: var(--text-muted);
 }
 
 .prd-stream-status .dot {
 width: 6px;
 height: 6px;
 border-radius: 50%;
 background: var(--accent-green);
 animation: pulse 1.5s infinite;
 }
 
 .prd-preview {
 background: var(--bg-primary);
 border: 1px solid var(--border);
 border-radius: 8px;
 padding: 20px;
 }
 
 .prd-preview h4 {
 font-size: 14px;
 margin-bottom: 16px;
 color: var(--accent-cyan);
 }
 
 /* PRD Browser Panel */
 .prd-browser-container {
 display: flex;
 flex-direction: column;
 height: 100%;
 background: var(--bg-primary);
 border: 1px solid var(--border);
 border-radius: 8px;
 overflow: hidden;
 }
 
 .prd-browser-toolbar {
 display: flex;
 align-items: center;
 gap: 8px;
 padding: 10px 12px;
 background: var(--bg-secondary);
 border-bottom: 1px solid var(--border);
 }
 
 .prd-browser-toolbar button {
 padding: 6px 10px;
 border: 1px solid var(--border);
 background: var(--bg-card);
 color: var(--text-primary);
 border-radius: 6px;
 cursor: pointer;
 font-size: 12px;
 transition: all 0.2s;
 }
 
 .prd-browser-toolbar button:hover {
 background: var(--bg-tertiary);
 border-color: var(--accent-cyan);
 }
 
 .prd-browser-status {
 display: flex;
 align-items: center;
 gap: 6px;
 padding: 4px 10px;
 background: var(--bg-card);
 border-radius: 6px;
 font-size: 11px;
 color: var(--text-muted);
 }
 
 .browser-url-bar {
 flex: 1;
 padding: 8px 12px;
 border: 1px solid var(--border);
 background: var(--bg-card);
 color: var(--text-primary);
 border-radius: 6px;
 font-size: 12px;
 font-family: 'JetBrains Mono', monospace;
 }
 
 .browser-url-bar:focus {
 outline: none;
 border-color: var(--accent-cyan);
 }
 
 .prd-browser-viewport {
 flex: 1;
 position: relative;
 min-height: 300px;
 background: var(--bg-tertiary);
 }
 
 .browser-screenshot-container {
 position: absolute;
 inset: 10px;
 border-radius: 6px;
 overflow: hidden;
 background: #1a1a1a;
 }
 
 .browser-screenshot-placeholder {
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 height: 100%;
 color: var(--text-muted);
 text-align: center;
 }
 
 .browser-screenshot-placeholder .icon {
 font-size: 48px;
 margin-bottom: 12px;
 opacity: 0.5;
 }
 
 .browser-screenshot {
 width: 100%;
 height: 100%;
 object-fit: contain;
 }
 
 .prd-browser-controls {
 display: flex;
 gap: 8px;
 padding: 10px 12px;
 background: var(--bg-secondary);
 border-top: 1px solid var(--border);
 }
 
 .prd-browser-controls button {
 padding: 8px 14px;
 border: 1px solid var(--border);
 background: var(--bg-card);
 color: var(--text-primary);
 border-radius: 6px;
 cursor: pointer;
 font-size: 12px;
 transition: all 0.2s;
 }
 
 .prd-browser-controls button:hover {
 background: var(--bg-tertiary);
 border-color: var(--accent-cyan);
 }
 
 .prd-browser-controls button.primary {
 background: var(--accent-cyan);
 color: var(--bg-primary);
 border-color: var(--accent-cyan);
 }
 
 .prd-browser-controls button.primary:hover {
 opacity: 0.9;
 }
 
 .prd-browser-controls button.danger {
 background: var(--accent-red);
 color: white;
 border-color: var(--accent-red);
 }
 
 .prd-browser-log {
 max-height: 100px;
 overflow-y: auto;
 padding: 8px 12px;
 background: var(--bg-primary);
 border-top: 1px solid var(--border);
 font-family: 'JetBrains Mono', monospace;
 font-size: 11px;
 }
 
 .browser-log-entry {
 padding: 2px 0;
 color: var(--text-muted);
 }
 
 .browser-log-time {
 color: var(--accent-purple);
 margin-right: 8px;
 }
 
 .browser-status-dot {
 width: 8px;
 height: 8px;
 border-radius: 50%;
 background: var(--text-muted);
 }
 
 .browser-status-dot.connected {
 background: var(--accent-green);
 box-shadow: 0 0 8px var(--accent-green);
 }
 
 .prd-stories {
 display: flex;
 flex-direction: column;
 gap: 12px;
 }
 
 .prd-story {
 background: var(--bg-card);
 border: 1px solid var(--border);
 border-radius: 8px;
 padding: 16px;
 }
 
 .prd-story-header {
 display: flex;
 align-items: center;
 gap: 10px;
 margin-bottom: 8px;
 }
 
 .prd-story-id {
 background: var(--accent-purple);
 color: white;
 padding: 2px 8px;
 border-radius: 4px;
 font-size: 11px;
 font-family: 'JetBrains Mono', monospace;
 }
 
 .prd-story-title {
 font-weight: 500;
 }
 
 .prd-story-criteria {
 font-size: 12px;
 color: var(--text-muted);
 margin-left: 20px;
 }
 
 .prd-story-criteria li {
 margin: 4px 0;
 }
 
 .prd-modal-footer {
 padding: 16px 24px;
 border-top: 1px solid var(--border);
 display: flex;
 align-items: center;
 justify-content: space-between;
 background: var(--bg-secondary);
 }
 
 .prd-footer-info {
 font-size: 12px;
 color: var(--text-muted);
 display: flex;
 align-items: center;
 gap: 16px;
 }
 
 .prd-footer-actions {
 display: flex;
 gap: 12px;
 }
 </style>
 
 <!-- PRD Editor Modal -->
 <div id="prdModal" class="prd-modal-overlay">
 <div class="prd-modal">
 <div class="prd-modal-header">
 <h2>
 PRD Generator
 <span class="source-badge" id="prdSourceBadge">source_name</span>
 </h2>
 <button class="prd-modal-close" onclick="closePrdModal()">√ó</button>
 </div>
 
 <div class="prd-modal-body">
 <div class="prd-sidebar">
 <h3> Variables</h3>
 <div class="prd-variables" id="prdVariables">
 <div class="prd-variable">
 <label>{{source_id}}</label>
 <input type="text" id="varSourceId" placeholder="source_id">
 </div>
 <div class="prd-variable">
 <label>{{source_name}}</label>
 <input type="text" id="varSourceName" placeholder="Source Name">
 </div>
 <div class="prd-variable">
 <label>{{source_url}}</label>
 <input type="text" id="varSourceUrl" placeholder="https://example.com">
 </div>
 <div class="prd-variable">
 <label>{{output_dir}}</label>
 <input type="text" id="varOutputDir" placeholder="data/source_name">
 </div>
 <div class="prd-variable">
 <label>{{scrape_mode}}</label>
 <select id="varScrapeMode">
 <option value="standard">Standard (httpx)</option>
 <option value="stealth">Stealth (Camoufox)</option>
 <option value="aggressive">Aggressive Stealth</option>
 </select>
 </div>
 <div class="prd-variable">
 <label>{{priority}}</label>
 <select id="varPriority">
 <option value="1">1 - Highest</option>
 <option value="2">2 - High</option>
 <option value="3" selected>3 - Normal</option>
 <option value="4">4 - Low</option>
 <option value="5">5 - Lowest</option>
 </select>
 </div>
 </div>
 
 <div class="prd-actions-sidebar">
 <h3 style="margin-top: 0;"> Actions</h3>
 <button class="prd-action-btn" id="btnDomainAnalysis" onclick="runDomainAnalysis()" title="Analyze website structure with browser">
 Run Domain Analysis
 </button>
 <button class="prd-action-btn" id="btnGeneratePrd" onclick="runPrdGeneration()" title="Generate PRD from analysis">
 Generate PRD
 </button>
 <button class="prd-action-btn" onclick="savePrdToRalph()" title="Save PRD for Ralph to use">
 Save PRD
 </button>
 <button class="prd-action-btn danger" onclick="clearPrdEditor()">
 Clear
 </button>
 </div>
 </div>
 
 <div class="prd-main">
 <div class="prd-tabs">
 <button class="prd-tab active" onclick="switchPrdTab('stream')"> Live Stream</button>
 <button class="prd-tab" onclick="switchPrdTab('editor')"> Editor</button>
 <button class="prd-tab" onclick="switchPrdTab('preview')"> Preview</button>
 <button class="prd-tab" onclick="switchPrdTab('browser')"> Browser</button>
 </div>
 
 <div class="prd-content">
 <div class="prd-panel active" id="prdStreamPanel">
 <div class="prd-stream" id="prdStreamContent">
 <span class="prd-stream-status" id="prdStreamStatus" style="display: none;">
 <span class="dot"></span>
 Generating...
 </span>
 <span id="prdStreamText">Click "Generate PRD" to start...</span>
 <span class="cursor" id="prdCursor" style="display: none;"></span>
 </div>
 </div>
 
 <div class="prd-panel" id="prdEditorPanel">
 <textarea class="prd-editor" id="prdEditorContent" placeholder="PRD JSON will appear here after generation..."></textarea>
 </div>
 
 <div class="prd-panel" id="prdPreviewPanel">
 <div class="prd-preview" id="prdPreviewContent">
 <p style="color: var(--text-muted);">Generate a PRD to see the preview...</p>
 </div>
 </div>
 
 <!-- Browser Panel inside PRD Modal -->
 <div class="prd-panel" id="prdBrowserPanel">
 <div class="prd-browser-container">
 <div class="prd-browser-toolbar">
 <div class="prd-browser-status">
 <div class="browser-status-dot" id="browserStatusDot"></div>
 <span id="browserStatusText">Disconnected</span>
 </div>
 <button onclick="browserBack()" title="Back">‚Üê</button>
 <button onclick="browserForward()" title="Forward">‚Üí</button>
 <button onclick="browserRefresh()" title="Refresh"></button>
 <input type="text" class="browser-url-bar" id="browserUrlBar" placeholder="Enter URL..." onkeypress="if(event.key==='Enter')browserNavigate()">
 <button onclick="browserNavigate()">Go</button>
 <button onclick="browserSnapshot()" title="Take Snapshot"></button>
 </div>
 
 <div class="prd-browser-viewport">
 <div class="browser-screenshot-container" id="browserScreenshotContainer">
 <div class="browser-screenshot-placeholder" id="browserPlaceholder">
 <div class="icon"></div>
 <div>Browser Preview</div>
 <div style="margin-top: 12px; font-size: 12px;">
 <button onclick="startBrowserSession()" style="padding: 8px 16px; background: var(--accent-cyan); border: none; border-radius: 6px; color: var(--bg-primary); cursor: pointer; font-weight: 600;">
 Start Browser Session
 </button>
 </div>
 <div style="margin-top: 8px; font-size: 11px; opacity: 0.7;">
 Uses Chrome DevTools Protocol for live preview
 </div>
 </div>
 <img id="browserScreenshot" class="browser-screenshot" style="display: none;" alt="Browser Screenshot">
 <div id="browserLoading" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
 <div style="font-size: 24px; animation: pulse 1s infinite;">‚è≥</div>
 <div style="margin-top: 8px; font-size: 12px; color: var(--text-muted);">Loading...</div>
 </div>
 </div>
 </div>
 
 <div class="prd-browser-controls">
 <button onclick="browserExecuteJS()" title="Execute JavaScript">
 Execute JS
 </button>
 <button onclick="browserExtractDOM()" title="Extract DOM Structure">
 Extract DOM
 </button>
 <button class="danger" onclick="stopBrowserSession()" id="stopBrowserBtn" style="display: none;">
 ‚èπ Stop Session
 </button>
 <button class="primary" onclick="startBrowserSession()" id="startBrowserBtn">
 Start Session
 </button>
 </div>
 
 <div class="prd-browser-log" id="browserLog">
 <div class="browser-log-entry">
 <span class="browser-log-time">[--:--:--]</span>
 <span>Browser ready. Click "Start Session" to begin.</span>
 </div>
 </div>
 </div>
 </div>
 </div>
 </div>
 </div>
 
 <div class="prd-modal-footer">
 <div class="prd-footer-info">
 <span id="prdStatus">Ready</span>
 <span id="prdTimestamp">--</span>
 </div>
 <div class="prd-footer-actions">
 <button class="prd-action-btn" onclick="closePrdModal()">Cancel</button>
 <button class="prd-action-btn" onclick="savePrdToFile()"> Save to File</button>
 <button class="prd-action-btn primary" onclick="usePrdAndStartRalph()"> Use & Start Ralph</button>
 </div>
 </div>
 </div>
 </div>
 
 <script>
 // ==========================================
 // PRD Editor Modal
 // ==========================================
 
 let currentPrdSource = null;
 let prdGenerationAbort = null;
 let currentPrdContent = '';
 
 async function openPrdModal(sourceId, sourceName, sourceUrl) {
 currentPrdSource = { id: sourceId, name: sourceName, url: sourceUrl };
 
 // Update modal header
 document.getElementById('prdSourceBadge').textContent = sourceId;
 
 // Pre-fill variables
 document.getElementById('varSourceId').value = sourceId;
 document.getElementById('varSourceName').value = sourceName;
 document.getElementById('varSourceUrl').value = sourceUrl || '';
 document.getElementById('varOutputDir').value = `data/${sourceId}`;
 
 // Reset button text to default
 document.getElementById('btnDomainAnalysis').textContent = ' Run Domain Analysis';
 document.getElementById('btnGeneratePrd').textContent = ' Generate PRD';
 
 // Check if files exist and update button text
 let analysisExists = false;
 let prdExists = false;
 
 try {
 const analysisCheck = await fetch(`${API_BASE}/prd/check-file`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({ filename: `${sourceId}_domain_analysis.md` })
 });
 const analysisResult = await analysisCheck.json();
 analysisExists = analysisResult.exists;
 
 const prdCheck = await fetch(`${API_BASE}/prd/check-file`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({ filename: `${sourceId}_prd.md` })
 });
 const prdResult = await prdCheck.json();
 prdExists = prdResult.exists;
 } catch (e) {
 console.log('Could not check file existence:', e);
 }
 
 // Update button text based on file existence
 if (analysisExists) {
 document.getElementById('btnDomainAnalysis').textContent = ' Reanalyze Domain';
 }
 if (prdExists) {
 document.getElementById('btnGeneratePrd').textContent = ' Regenerate PRD';
 }
 
 // Build status message
 let statusMsg = ` PRD Generator for ${sourceName}\n\n` +
 `Source ID: ${sourceId}\n` +
 `URL: ${sourceUrl || 'Not set'}\n\n` +
 `\n\n` +
 ` Status:\n\n` +
 ` Domain Analysis: ${analysisExists ? ' Exists' : ' Not found'}\n` +
 ` PRD: ${prdExists ? ' Exists' : ' Not found'}\n\n` +
 `\n\n` +
 ` Available Actions:\n\n` +
 ` ${analysisExists ? 'Reanalyze Domain' : 'Run Domain Analysis'}\n` +
 ` Analyzes the website structure using browser automation\n\n` +
 ` ${prdExists ? 'Regenerate PRD' : 'Generate PRD'}\n` +
 ` Creates a PRD from the domain analysis\n\n` +
 `\n\n` +
 `Click a button to start.`;
 
 document.getElementById('prdStreamText').textContent = statusMsg;
 document.getElementById('prdEditorContent').value = '';
 document.getElementById('prdPreviewContent').innerHTML = '<p style="color: var(--text-muted);">Generate a PRD to see the preview...</p>';
 document.getElementById('prdStreamStatus').style.display = 'none';
 document.getElementById('prdCursor').style.display = 'none';
 document.getElementById('prdStatus').textContent = 'Ready';
 document.getElementById('prdTimestamp').textContent = '--';
 
 // Show modal
 document.getElementById('prdModal').classList.add('visible');
 switchPrdTab('stream');
 }
 
 // Manual trigger for domain analysis
 async function runDomainAnalysis() {
 if (!currentPrdSource) return;
 const { id: sourceId, name: sourceName, url: sourceUrl } = currentPrdSource;
 
 const streamEl = document.getElementById('prdStreamText');
 document.getElementById('prdStreamStatus').style.display = 'flex';
 document.getElementById('prdCursor').style.display = 'inline-block';
 document.getElementById('prdStatus').textContent = 'Analyzing...';
 
 streamEl.textContent = ` Starting domain analysis for ${sourceName}...\n`;
 streamEl.textContent += ` Target: ${sourceUrl || 'No URL'}\n\n`;
 
 try {
 const response = await fetch(`${API_BASE}/prd/analyze-domain`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({ sourceId, sourceName, sourceUrl })
 });
 
 const result = await response.json();
 
 if (result.success) {
 streamEl.textContent += result.analysis || ' Analysis complete.\n';
 streamEl.textContent += `\n\n Saved to: ${result.path}\n`;
 streamEl.textContent += `\nMethod: ${result.method || 'unknown'}\n`;
 } else {
 streamEl.textContent += `\n Error: ${result.error}\n`;
 }
 } catch (error) {
 streamEl.textContent += `\n Error: ${error.message}\n`;
 }
 
 document.getElementById('prdStreamStatus').style.display = 'none';
 document.getElementById('prdCursor').style.display = 'none';
 document.getElementById('prdStatus').textContent = 'Ready';
 document.getElementById('prdTimestamp').textContent = new Date().toLocaleTimeString();
 
 // Auto-switch to preview after 1 second
 setTimeout(() => switchPrdTab('preview'), 1000);
 }
 
 // Manual trigger for PRD generation
 async function runPrdGeneration() {
 if (!currentPrdSource) return;
 const { id: sourceId, name: sourceName, url: sourceUrl } = currentPrdSource;
 
 const streamEl = document.getElementById('prdStreamText');
 document.getElementById('prdStreamStatus').style.display = 'flex';
 document.getElementById('prdCursor').style.display = 'inline-block';
 document.getElementById('prdStatus').textContent = 'Generating...';
 
 streamEl.textContent = ` Generating PRD for ${sourceName}...\n\n`;
 
 try {
 const response = await fetch(`${API_BASE}/prd/generate-from-analysis`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({ sourceId, sourceName, sourceUrl })
 });
 
 const result = await response.json();
 
 if (result.success || result.prd) {
 const prd = result.prd;
 const prdJson = JSON.stringify(prd, null, 2);
 streamEl.textContent += prdJson;
 streamEl.textContent += `\n\n PRD generated!\n`;
 
 document.getElementById('prdEditorContent').value = prdJson;
 updatePrdPreview(prd);
 currentPrdContent = prdJson;
 } else {
 streamEl.textContent += `\n Error: ${result.error}\n`;
 }
 } catch (error) {
 streamEl.textContent += `\n Error: ${error.message}\n`;
 }
 
 document.getElementById('prdStreamStatus').style.display = 'none';
 document.getElementById('prdCursor').style.display = 'none';
 document.getElementById('prdStatus').textContent = 'Ready';
 document.getElementById('prdTimestamp').textContent = new Date().toLocaleTimeString();
 
 // Auto-switch to preview after 1 second
 setTimeout(() => switchPrdTab('preview'), 1000);
 }
 
 // Helper to stream text character by character
 async function streamText(element, text, delay = 5) {
 for (const char of text) {
 currentPrdContent += char;
 element.textContent = currentPrdContent;
 element.parentElement.scrollTop = element.parentElement.scrollHeight;
 if (delay > 0) {
 await new Promise(r => setTimeout(r, char === '\n' ? delay * 4 : delay));
 }
 }
 }
 
 function closePrdModal() {
 document.getElementById('prdModal').classList.remove('visible');
 if (prdGenerationAbort) {
 prdGenerationAbort.abort();
 prdGenerationAbort = null;
 }
 currentPrdSource = null;
 }
 
 function switchPrdTab(tab) {
 // Update tabs
 document.querySelectorAll('.prd-tab').forEach(t => t.classList.remove('active'));
 document.querySelector(`.prd-tab[onclick="switchPrdTab('${tab}')"]`).classList.add('active');
 
 // Update panels
 document.querySelectorAll('.prd-panel').forEach(p => p.classList.remove('active'));
 document.getElementById(`prd${tab.charAt(0).toUpperCase() + tab.slice(1)}Panel`).classList.add('active');
 }
 
 function getVariables() {
 return {
 source_id: document.getElementById('varSourceId').value,
 source_name: document.getElementById('varSourceName').value,
 source_url: document.getElementById('varSourceUrl').value,
 output_dir: document.getElementById('varOutputDir').value,
 scrape_mode: document.getElementById('varScrapeMode').value,
 priority: document.getElementById('varPriority').value
 };
 }
 
 async function generatePrd() {
 const vars = getVariables();
 
 // Reset and show streaming
 switchPrdTab('stream');
 document.getElementById('prdStreamText').textContent = '';
 document.getElementById('prdStreamStatus').style.display = 'flex';
 document.getElementById('prdCursor').style.display = 'inline-block';
 document.getElementById('prdStatus').textContent = 'Generating...';
 
 currentPrdContent = '';
 
 // Create PRD template with variables
 const template = createPrdTemplate(vars);
 
 // Simulate streaming (in production, this would connect to a real streaming endpoint)
 await streamPrdGeneration(template, vars);
 }
 
 function createPrdTemplate(vars) {
 return {
 projectName: `${vars.source_name} Scraping`,
 sourceId: vars.source_id,
 branchName: "main",
 targetUrl: vars.source_url,
 outputDir: vars.output_dir,
 scrapeMode: vars.scrape_mode,
 priority: parseInt(vars.priority),
 userStories: [
 {
 id: "URL-001",
 title: "Discover all vehicle/build URLs on the site",
 acceptanceCriteria: [
 "urls.jsonl contains all discoverable URLs",
 "URLs are deduplicated and normalized",
 "Pagination/infinite scroll handled"
 ],
 priority: 1,
 passes: false
 },
 {
 id: "HTML-001", 
 title: "Scrape HTML for all discovered URLs",
 acceptanceCriteria: [
 "HTML files saved for each URL",
 vars.scrape_mode !== 'standard' ? "Use stealth scraper for anti-bot protection" : "Use standard httpx scraper",
 "Rate limiting: 2-5 second delays"
 ],
 priority: 1,
 passes: false
 },
 {
 id: "BUILD-001",
 title: "Extract structured build data from HTML",
 acceptanceCriteria: [
 "builds.jsonl contains vehicle data",
 "Required fields: build_id, year, make, model, source_url",
 "Images extracted to gallery_images array"
 ],
 priority: 1,
 passes: false
 },
 {
 id: "MOD-001",
 title: "Extract modifications from builds",
 acceptanceCriteria: [
 "mods.jsonl contains modification data",
 "Categories: Engine, Suspension, Wheels, etc.",
 "Brand and part names extracted where available"
 ],
 priority: 2,
 passes: false
 }
 ],
 variables: vars,
 createdAt: new Date().toISOString(),
 createdBy: "dashboard-prd-generator"
 };
 }
 
 async function streamPrdGeneration(template, vars) {
 const streamEl = document.getElementById('prdStreamText');
 const jsonStr = JSON.stringify(template, null, 2);
 
 // Stream character by character
 for (let i = 0; i < jsonStr.length; i++) {
 if (prdGenerationAbort?.signal.aborted) break;
 
 currentPrdContent += jsonStr[i];
 streamEl.textContent = currentPrdContent;
 
 // Scroll to bottom
 streamEl.parentElement.scrollTop = streamEl.parentElement.scrollHeight;
 
 // Variable speed based on character
 const char = jsonStr[i];
 let delay = 2;
 if (char === '\n') delay = 20;
 else if (char === '{' || char === '}') delay = 30;
 else if (char === ',') delay = 15;
 
 await new Promise(r => setTimeout(r, delay));
 }
 
 // Done streaming
 document.getElementById('prdStreamStatus').style.display = 'none';
 document.getElementById('prdCursor').style.display = 'none';
 document.getElementById('prdStatus').textContent = 'Generated';
 document.getElementById('prdTimestamp').textContent = new Date().toLocaleTimeString();
 
 // Update editor and preview
 document.getElementById('prdEditorContent').value = currentPrdContent;
 updatePrdPreview(template);
 }
 
 function updatePrdPreview(prd) {
 const previewEl = document.getElementById('prdPreviewContent');
 
 if (!prd) {
 previewEl.innerHTML = '<p style="color: var(--text-muted);">No PRD data available</p>';
 return;
 }
 
 const stories = prd.userStories || [];
 const storiesHtml = stories.length > 0 ? stories.map(story => `
 <div class="prd-story">
 <div class="prd-story-header">
 <span class="prd-story-id">${story.id || '?'}</span>
 <span class="prd-story-title">${story.title || 'Untitled'}</span>
 </div>
 <ul class="prd-story-criteria">
 ${(story.acceptanceCriteria || []).map(c => `<li> ${c}</li>`).join('')}
 </ul>
 </div>
 `).join('') : '<p style="color: var(--text-muted);">No user stories defined</p>';
 
 previewEl.innerHTML = `
 <h4> ${prd.projectName || 'Unnamed Project'}</h4>
 <div style="margin-bottom: 16px; font-size: 13px; color: var(--text-secondary);">
 <strong>Target:</strong> ${prd.targetUrl || 'Not set'}<br>
 <strong>Output:</strong> ${prd.outputDir || 'Not set'}<br>
 <strong>Mode:</strong> ${prd.scrapeMode || 'Not set'}
 </div>
 <h4 style="margin-top: 20px;"> User Stories</h4>
 <div class="prd-stories">
 ${storiesHtml}
 </div>
 `;
 }
 
 async function generatePrdVariant() {
 const vars = getVariables();
 
 // Create a variant with different strategies
 const strategies = ['aggressive', 'conservative', 'parallel', 'sequential'];
 const strategy = strategies[Math.floor(Math.random() * strategies.length)];
 
 vars.variant_strategy = strategy;
 
 showNotification(` Generating ${strategy} variant...`, 'info');
 await generatePrd();
 }
 
 async function analyzeSiteStructure() {
 if (!currentPrdSource?.url) {
 showNotification(' No source URL to analyze', 'error');
 return;
 }
 
 const streamEl = document.getElementById('prdStreamText');
 switchPrdTab('stream');
 document.getElementById('prdStreamStatus').style.display = 'flex';
 document.getElementById('prdCursor').style.display = 'inline-block';
 document.getElementById('prdStatus').textContent = 'Analyzing...';
 
 // Simulate site analysis
 const analysisSteps = [
 ` Analyzing ${currentPrdSource.url}...\n`,
 ` Fetching homepage...\n`,
 ` Page loaded successfully\n\n`,
 ` Site Analysis Results:\n`,
 `${''.repeat(40)}\n`,
 `Domain: ${new URL(currentPrdSource.url).hostname}\n`,
 `Protocol: ${new URL(currentPrdSource.url).protocol}\n\n`,
 ` Detected Patterns:\n`,
 ` ‚Ä¢ Pagination: Yes (likely)\n`,
 ` ‚Ä¢ JavaScript: Heavy usage detected\n`,
 ` ‚Ä¢ Anti-bot: Unknown (needs testing)\n\n`,
 ` Recommended Configuration:\n`,
 ` ‚Ä¢ Scrape Mode: stealth\n`,
 ` ‚Ä¢ Rate Limit: 3-5 seconds\n`,
 ` ‚Ä¢ Concurrent: 2-3 browsers\n\n`,
 ` Analysis complete. Click "Generate PRD" to create a tailored PRD.`
 ];
 
 currentPrdContent = '';
 streamEl.textContent = '';
 
 for (const step of analysisSteps) {
 for (const char of step) {
 currentPrdContent += char;
 streamEl.textContent = currentPrdContent;
 streamEl.parentElement.scrollTop = streamEl.parentElement.scrollHeight;
 await new Promise(r => setTimeout(r, char === '\n' ? 50 : 10));
 }
 }
 
 document.getElementById('prdStreamStatus').style.display = 'none';
 document.getElementById('prdCursor').style.display = 'none';
 document.getElementById('prdStatus').textContent = 'Analysis complete';
 document.getElementById('prdTimestamp').textContent = new Date().toLocaleTimeString();
 }
 
 function clearPrdEditor() {
 currentPrdContent = '';
 document.getElementById('prdStreamText').textContent = 'Click "Generate PRD" to start...';
 document.getElementById('prdEditorContent').value = '';
 document.getElementById('prdPreviewContent').innerHTML = '<p style="color: var(--text-muted);">Generate a PRD to see the preview...</p>';
 document.getElementById('prdStatus').textContent = 'Ready';
 document.getElementById('prdTimestamp').textContent = '--';
 }
 
 async function savePrdToFile() {
 const content = document.getElementById('prdEditorContent').value;
 if (!content) {
 showNotification(' No PRD content to save', 'error');
 return;
 }
 
 try {
 const prd = JSON.parse(content);
 
 const response = await fetch(`${API_BASE}/prd/save`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({ prd })
 });
 
 if (response.ok) {
 showNotification(' PRD saved to scripts/ralph/prd.json', 'success');
 } else {
 // Fallback: download as file
 const blob = new Blob([content], { type: 'application/json' });
 const url = URL.createObjectURL(blob);
 const a = document.createElement('a');
 a.href = url;
 a.download = `prd_${currentPrdSource?.id || 'unknown'}.json`;
 a.click();
 URL.revokeObjectURL(url);
 showNotification(' PRD downloaded as file', 'info');
 }
 } catch (err) {
 showNotification(` Invalid JSON: ${err.message}`, 'error');
 }
 }
 
 async function usePrdAndStartRalph() {
 const content = document.getElementById('prdEditorContent').value;
 if (!content) {
 showNotification(' No PRD content', 'error');
 return;
 }
 
 try {
 const prd = JSON.parse(content);
 
 // Save PRD first
 await fetch(`${API_BASE}/prd/save`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({ prd })
 });
 
 closePrdModal();
 
 // Start Ralph
 showNotification(` Starting Ralph for ${prd.sourceId}...`, 'info');
 
 const response = await fetch(`${API_BASE}/ralph/start`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({
 iterations: 25,
 sources: [prd.sourceId]
 })
 });
 
 const data = await response.json();
 
 if (data.success) {
 showNotification(` Ralph started for ${prd.sourceId}`, 'success');
 setTimeout(updateDashboard, 1000);
 } else {
 showNotification(` Failed: ${data.error}`, 'error');
 }
 } catch (err) {
 showNotification(` Error: ${err.message}`, 'error');
 }
 }
 
 // Close modal on overlay click
 document.getElementById('prdModal').addEventListener('click', (e) => {
 if (e.target.id === 'prdModal') {
 closePrdModal();
 }
 });
 
 // Close modal on Escape
 document.addEventListener('keydown', (e) => {
 if (e.key === 'Escape' && document.getElementById('prdModal').classList.contains('visible')) {
 closePrdModal();
 }
 });
 </script>
</body>
</html>

