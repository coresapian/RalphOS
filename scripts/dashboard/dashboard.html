<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ralph Dashboard</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    :root {
      --bg-primary: #0a0a0f;
      --bg-secondary: #12121a;
      --bg-card: #1a1a24;
      --border: #2a2a3a;
      --text-primary: #e4e4e7;
      --text-secondary: #a1a1aa;
      --text-muted: #71717a;
      --accent-cyan: #22d3ee;
      --accent-green: #4ade80;
      --accent-yellow: #facc15;
      --accent-red: #f87171;
      --accent-purple: #a78bfa;
      --accent-blue: #60a5fa;
    }
    
    body {
      font-family: 'Space Grotesk', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      padding: 24px;
      background-image: 
        radial-gradient(ellipse at top left, rgba(34, 211, 238, 0.05) 0%, transparent 50%),
        radial-gradient(ellipse at bottom right, rgba(167, 139, 250, 0.05) 0%, transparent 50%);
    }
    
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 32px;
      padding-bottom: 24px;
      border-bottom: 1px solid var(--border);
    }
    
    .logo {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    
    .logo-icon {
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    
    .logo h1 {
      font-size: 28px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .logo p {
      color: var(--text-muted);
      font-size: 14px;
    }
    
    .status-badge {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 999px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
    }
    
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    
    .status-dot.running { background: var(--accent-green); }
    .status-dot.stopped { background: var(--accent-red); }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .main-grid {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 24px;
    }
    
    .card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      overflow: hidden;
    }
    
    .card-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .card-header h2 {
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .card-body {
      padding: 20px;
    }
    
    .card-body.scrollable {
      max-height: 600px;
      overflow-y: auto;
    }
    
    .card-body.scrollable::-webkit-scrollbar {
      width: 8px;
    }
    
    .card-body.scrollable::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }
    
    .card-body.scrollable::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }
    
    .card-body.scrollable::-webkit-scrollbar-thumb:hover {
      background: var(--accent-cyan);
    }
    
    .log-output {
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      line-height: 1.6;
      background: var(--bg-primary);
      border-radius: 8px;
      padding: 16px;
      height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-all;
    }
    
    .log-output::-webkit-scrollbar {
      width: 8px;
    }
    
    .log-output::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }
    
    .log-output::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }
    
    .source-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      margin: 0 -12px;
      border-bottom: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .source-item:hover {
      background: var(--bg-secondary);
      border-color: var(--accent-cyan);
    }
    
    .source-item:last-child {
      border-bottom: none;
    }
    
    .source-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .source-status {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      flex-shrink: 0;
    }
    
    .source-status:hover {
      transform: scale(1.4);
      box-shadow: 0 0 12px currentColor;
    }
    
    .source-status.completed { background: var(--accent-green); color: var(--accent-green); }
    .source-status.in_progress { 
      background: var(--accent-yellow); 
      color: var(--accent-yellow);
      animation: statusPulse 1.5s infinite;
    }
    .source-status.pending { background: var(--text-muted); color: var(--text-muted); }
    .source-status.blocked { background: var(--accent-red); color: var(--accent-red); }
    
    @keyframes statusPulse {
      0%, 100% { opacity: 1; box-shadow: 0 0 4px currentColor; }
      50% { opacity: 0.6; box-shadow: 0 0 8px currentColor; }
    }
    
    /* Source Action Menu */
    .source-action-menu {
      position: fixed;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px 0;
      min-width: 200px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      z-index: 1000;
      display: none;
    }
    
    .source-action-menu.visible {
      display: block;
      animation: menuFadeIn 0.15s ease-out;
    }
    
    @keyframes menuFadeIn {
      from { opacity: 0; transform: translateY(-8px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .source-action-menu-header {
      padding: 8px 16px 12px;
      border-bottom: 1px solid var(--border);
      margin-bottom: 8px;
    }
    
    .source-action-menu-header .name {
      font-weight: 600;
      font-size: 14px;
      color: var(--text-primary);
    }
    
    .source-action-menu-header .url {
      font-size: 11px;
      color: var(--text-muted);
      font-family: 'JetBrains Mono', monospace;
      margin-top: 4px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .source-action-item {
      padding: 10px 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      transition: background 0.15s;
      font-size: 13px;
    }
    
    .source-action-item:hover {
      background: var(--bg-secondary);
    }
    
    .source-action-item .icon {
      width: 20px;
      text-align: center;
    }
    
    .source-action-item.start { color: var(--accent-green); }
    .source-action-item.stop { color: var(--accent-red); }
    .source-action-item.generate { color: var(--accent-cyan); }
    .source-action-item.view { color: var(--accent-purple); }
    .source-action-item.disabled {
      opacity: 0.4;
      pointer-events: none;
    }
    
    .source-action-divider {
      height: 1px;
      background: var(--border);
      margin: 8px 0;
    }
    
    .source-name {
      font-weight: 500;
    }
    
    .source-stats {
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      color: var(--text-muted);
    }
    
    .progress-bar {
      width: 100px;
      height: 6px;
      background: var(--bg-primary);
      border-radius: 3px;
      overflow: hidden;
    }
    
    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-cyan), var(--accent-green));
      transition: width 0.3s;
    }
    
    /* Header Pipeline Stats */
    .header-pipeline {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
    }
    
    .header-stage {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 6px 16px;
      border-radius: 8px;
      min-width: 80px;
      transition: all 0.2s;
    }
    
    .header-stage.active {
      background: rgba(34, 211, 238, 0.1);
    }
    
    .header-stage.complete {
      background: rgba(74, 222, 128, 0.1);
    }
    
    .header-stage-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 16px;
      font-weight: 700;
      color: var(--text-primary);
    }
    
    .header-stage.active .header-stage-value { color: var(--accent-cyan); }
    .header-stage.complete .header-stage-value { color: var(--accent-green); }
    
    .header-stage-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .header-stage-arrow {
      color: var(--text-muted);
      font-size: 14px;
    }
    
    .refresh-time {
      font-size: 11px;
      color: var(--text-muted);
      font-family: 'JetBrains Mono', monospace;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .live-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent-green);
      animation: livePulse 2s infinite;
    }
    
    @keyframes livePulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.4; transform: scale(0.8); }
    }
    
    .live-dot.error {
      background: var(--accent-red);
      animation: none;
    }
    
    .sources-controls {
      display: flex;
      gap: 8px;
    }
    
    .sources-filter-input {
      flex: 1;
      padding: 8px 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      outline: none;
      transition: border-color 0.2s;
    }
    
    .sources-filter-input:focus {
      border-color: var(--accent-cyan);
    }
    
    .sources-filter-input::placeholder {
      color: var(--text-muted);
    }
    
    .sources-sort-select {
      padding: 8px 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      outline: none;
      cursor: pointer;
      transition: border-color 0.2s;
    }
    
    .sources-sort-select:focus,
    .sources-sort-select:hover {
      border-color: var(--accent-cyan);
    }
    
    .no-results {
      text-align: center;
      padding: 24px;
      color: var(--text-muted);
      font-size: 13px;
    }
    
    .error { color: var(--accent-red); }
    .success { color: var(--accent-green); }
    .warning { color: var(--accent-yellow); }
    .info { color: var(--accent-cyan); }
    
    /* Scraper Panel Styles */
    .scraper-panel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      margin-bottom: 24px;
      overflow: hidden;
    }
    
    .scraper-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .scraper-header:hover {
      background: var(--bg-secondary);
    }
    
    .scraper-header h2 {
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .scraper-toggle {
      font-size: 18px;
      transition: transform 0.3s;
    }
    
    .scraper-toggle.open {
      transform: rotate(180deg);
    }
    
    .scraper-body {
      padding: 20px;
      display: none;
    }
    
    .scraper-body.open {
      display: block;
    }
    
    .form-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 16px;
      margin-bottom: 20px;
    }
    
    .form-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .form-group.full-width {
      grid-column: span 3;
    }
    
    .form-group label {
      font-size: 12px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .form-group input,
    .form-group select {
      padding: 10px 14px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      transition: border-color 0.2s;
    }
    
    .form-group input:focus,
    .form-group select:focus {
      outline: none;
      border-color: var(--accent-cyan);
    }
    
    .form-group input::placeholder {
      color: var(--text-muted);
    }
    
    .btn-group {
      display: flex;
      gap: 12px;
    }
    
    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      color: var(--bg-primary);
    }
    
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(34, 211, 238, 0.3);
    }
    
    .btn-primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .btn-danger {
      background: var(--accent-red);
      color: white;
    }
    
    .btn-danger:hover {
      background: #ef4444;
    }
    
    .btn-secondary {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }
    
    .btn-secondary:hover {
      border-color: var(--accent-cyan);
    }
    
    .scraper-status {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: var(--bg-primary);
      border-radius: 8px;
      margin-bottom: 16px;
    }
    
    .scraper-status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }
    
    .scraper-status-dot.running {
      background: var(--accent-green);
      animation: pulse 2s infinite;
    }
    
    .scraper-status-dot.stopped {
      background: var(--text-muted);
    }
    
    .scraper-stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      margin-top: 16px;
    }
    
    .scraper-stat {
      padding: 12px;
      background: var(--bg-primary);
      border-radius: 8px;
      text-align: center;
    }
    
    .scraper-stat .stat-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-bottom: 4px;
    }
    
    .scraper-stat .stat-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 18px;
      font-weight: 600;
    }
    
    .scraper-stat.green .stat-value { color: var(--accent-green); }
    .scraper-stat.red .stat-value { color: var(--accent-red); }
    .scraper-stat.yellow .stat-value { color: var(--accent-yellow); }
    .scraper-stat.cyan .stat-value { color: var(--accent-cyan); }
    
    .help-text {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 4px;
    }
    
    .preset-buttons {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .preset-btn {
      padding: 6px 12px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .preset-btn:hover {
      border-color: var(--accent-cyan);
      color: var(--accent-cyan);
    }
    
    .preset-btn.active {
      background: rgba(34, 211, 238, 0.1);
      border-color: var(--accent-cyan);
      color: var(--accent-cyan);
    }
    
    .scraper-log {
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      background: var(--bg-primary);
      border-radius: 8px;
      padding: 12px;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
      margin-top: 16px;
      display: none;
    }
    
    .scraper-log.visible {
      display: block;
    }
    
    /* Ralph Panel Styles */
    .ralph-panel {
      background: linear-gradient(135deg, rgba(74, 222, 128, 0.05), rgba(34, 211, 238, 0.05));
      border: 1px solid var(--accent-green);
      border-radius: 16px;
      margin-bottom: 24px;
      overflow: hidden;
    }
    
    .ralph-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .ralph-header:hover {
      background: rgba(74, 222, 128, 0.1);
    }
    
    .ralph-header h2 {
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--accent-green);
    }
    
    .ralph-body {
      padding: 20px;
      display: none;
    }
    
    .ralph-body.open {
      display: block;
    }
    
    .ralph-status {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 16px;
      background: var(--bg-primary);
      border-radius: 12px;
      margin-bottom: 16px;
    }
    
    .ralph-status-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .ralph-info {
      flex: 1;
    }
    
    .ralph-info .project-name {
      font-weight: 600;
      color: var(--accent-green);
    }
    
    .ralph-info .story-progress {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 4px;
    }
    
    .iterations-input {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .iterations-input label {
      font-size: 13px;
      color: var(--text-secondary);
    }
    
    .iterations-input input {
      width: 80px;
      padding: 8px 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      text-align: center;
    }
    
    .log-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
    }
    
    .log-controls button {
      padding: 4px 8px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      font-size: 11px;
      cursor: pointer;
    }
    
    .log-controls button:hover {
      border-color: var(--accent-cyan);
      color: var(--accent-cyan);
    }
    
    .log-controls button.active {
      background: rgba(34, 211, 238, 0.2);
      border-color: var(--accent-cyan);
      color: var(--accent-cyan);
    }
    
    .log-controls button.kill-btn {
      background: rgba(248, 113, 113, 0.15);
      border-color: var(--accent-red);
      color: var(--accent-red);
      font-weight: 600;
    }
    
    .log-controls button.kill-btn:hover {
      background: rgba(248, 113, 113, 0.3);
      border-color: var(--accent-red);
      color: var(--accent-red);
    }
    
    .log-controls button.kill-btn.killing {
      animation: pulse-red 0.5s infinite;
      pointer-events: none;
    }
    
    @keyframes pulse-red {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .auto-scroll-indicator {
      font-size: 10px;
      color: var(--text-muted);
    }
    
    /* Settings Button */
    .settings-btn {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--bg-card);
      font-size: 18px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .settings-btn:hover {
      border-color: var(--accent-cyan);
      background: var(--bg-secondary);
      transform: rotate(30deg);
    }
    
    /* Settings Panel Overlay */
    .settings-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(4px);
      z-index: 2500;
      display: none;
      align-items: flex-start;
      justify-content: flex-end;
      padding: 24px;
    }
    
    .settings-overlay.visible {
      display: flex;
      animation: fadeIn 0.2s ease-out;
    }
    
    .settings-panel {
      width: 500px;
      max-height: calc(100vh - 48px);
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
      from { opacity: 0; transform: translateX(20px); }
      to { opacity: 1; transform: translateX(0); }
    }
    
    .settings-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--bg-secondary);
    }
    
    .settings-header h2 {
      font-size: 18px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .settings-close {
      width: 32px;
      height: 32px;
      border: none;
      background: var(--bg-card);
      border-radius: 8px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 18px;
      transition: all 0.2s;
    }
    
    .settings-close:hover {
      background: var(--accent-red);
      color: white;
    }
    
    .settings-content {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
    }
    
    .settings-section {
      margin-bottom: 24px;
    }
    
    .settings-section-title {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-muted);
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    /* Browser Preview Panel */
    .browser-btn {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--bg-card);
      font-size: 18px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .browser-btn:hover {
      border-color: var(--accent-purple);
      background: var(--bg-secondary);
    }
    
    .browser-btn.active {
      border-color: var(--accent-purple);
      background: rgba(167, 139, 250, 0.2);
    }
    
    .browser-panel {
      position: fixed;
      top: 0;
      right: -700px;
      width: 700px;
      height: 100vh;
      background: var(--bg-card);
      border-left: 1px solid var(--border);
      z-index: 1000;
      transition: right 0.3s ease-out;
      display: flex;
      flex-direction: column;
    }
    
    .browser-panel.visible {
      right: 0;
    }
    
    .browser-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--bg-secondary);
    }
    
    .browser-header h2 {
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .browser-status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text-muted);
    }
    
    .browser-status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
    }
    
    .browser-status-dot.connected {
      background: var(--accent-green);
      animation: pulse 2s infinite;
    }
    
    .browser-status-dot.loading {
      background: var(--accent-yellow);
      animation: pulse 0.5s infinite;
    }
    
    .browser-close {
      width: 32px;
      height: 32px;
      border: none;
      background: var(--bg-card);
      border-radius: 8px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 18px;
    }
    
    .browser-close:hover {
      background: var(--bg-primary);
      color: var(--text-primary);
    }
    
    .browser-toolbar {
      padding: 12px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    .browser-url-bar {
      flex: 1;
      padding: 8px 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
    }
    
    .browser-toolbar button {
      padding: 8px 12px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 12px;
      white-space: nowrap;
    }
    
    .browser-toolbar button:hover {
      border-color: var(--accent-cyan);
      color: var(--accent-cyan);
    }
    
    .browser-viewport {
      flex: 1;
      padding: 16px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .browser-screenshot-container {
      flex: 1;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .browser-screenshot {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
    
    .browser-screenshot-placeholder {
      color: var(--text-muted);
      text-align: center;
      padding: 40px;
    }
    
    .browser-screenshot-placeholder .icon {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }
    
    .browser-log {
      height: 150px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow-y: auto;
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      padding: 12px;
    }
    
    .browser-log-entry {
      margin-bottom: 4px;
      display: flex;
      gap: 8px;
    }
    
    .browser-log-time {
      color: var(--text-muted);
      flex-shrink: 0;
    }
    
    .browser-log-action {
      color: var(--accent-cyan);
    }
    
    .browser-log-url {
      color: var(--accent-purple);
      word-break: break-all;
    }
    
    .browser-log-error {
      color: var(--accent-red);
    }
    
    .browser-log-success {
      color: var(--accent-green);
    }
    
    .browser-controls {
      padding: 12px 20px;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }
    
    .browser-controls button {
      padding: 8px 16px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg-secondary);
      color: var(--text-primary);
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
    }
    
    .browser-controls button:hover {
      border-color: var(--accent-cyan);
    }
    
    .browser-controls button.primary {
      background: var(--accent-cyan);
      border-color: var(--accent-cyan);
      color: var(--bg-primary);
    }
    
    .browser-controls button.primary:hover {
      background: #1cb5d1;
    }
    
    .browser-controls button.danger {
      border-color: var(--accent-red);
      color: var(--accent-red);
    }
    
    .browser-controls button.danger:hover {
      background: rgba(248, 113, 113, 0.2);
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="logo">
      <div class="logo-icon">ü§ñ</div>
      <div>
        <h1>Ralph Dashboard</h1>
        <p>Autonomous AI Agent Monitor</p>
      </div>
    </div>
    
    <!-- Pipeline Stats (inline) -->
    <div class="header-pipeline" id="pipelineStages">
      <div class="header-stage" id="stage1">
        <span class="header-stage-value">--</span>
        <span class="header-stage-label">URLs</span>
      </div>
      <span class="header-stage-arrow">‚Üí</span>
      <div class="header-stage" id="stage2">
        <span class="header-stage-value">--</span>
        <span class="header-stage-label">HTML</span>
      </div>
      <span class="header-stage-arrow">‚Üí</span>
      <div class="header-stage" id="stage3">
        <span class="header-stage-value">--</span>
        <span class="header-stage-label">Builds</span>
      </div>
      <span class="header-stage-arrow">‚Üí</span>
      <div class="header-stage" id="stage4">
        <span class="header-stage-value">--</span>
        <span class="header-stage-label">Mods</span>
      </div>
    </div>
    
    <button class="browser-btn" onclick="toggleBrowserPanel()" title="Browser Preview" id="browserBtn">
      üåê
    </button>
    <button class="settings-btn" onclick="toggleSettingsPanel()" title="Settings">
      ‚öôÔ∏è
    </button>
  </div>
  
  <div class="main-grid">
    <div class="card">
      <div class="card-header">
        <div class="status-badge" style="padding: 6px 12px;">
          <div class="status-dot" id="statusDot"></div>
          <span id="statusText">Checking...</span>
        </div>
        <div class="log-controls">
          <button onclick="refreshLogNow()" title="Refresh now">üîÑ</button>
          <button id="autoRefreshBtn" class="active" onclick="toggleAutoRefresh()" title="Toggle auto-refresh">Auto</button>
          <button onclick="clearLogDisplay()" title="Clear display">Clear</button>
          <button id="killAllBtn" class="kill-btn" onclick="killAllRalphs()" title="Kill all Ralph processes">‚ò†Ô∏è Kill All</button>
          <span class="auto-scroll-indicator" id="autoScrollIndicator">‚Üì Auto-scroll ON</span>
        </div>
        <span class="refresh-time" id="logRefresh">--</span>
      </div>
      <div class="card-body">
        <div class="log-output" id="logOutput">Loading...</div>
      </div>
    </div>
    
    <div class="card">
      <div class="card-header" style="flex-direction: column; align-items: stretch; gap: 12px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <h2 style="display: flex; align-items: center; gap: 16px;">
            üìä Sources
            <span style="display: flex; gap: 12px; font-size: 12px; font-weight: 500;">
              <span style="color: var(--accent-cyan);"><span id="totalSources">--</span> total</span>
              <span style="color: var(--accent-green);">‚úì <span id="completedSources">--</span></span>
              <span style="color: var(--accent-yellow);">‚è≥ <span id="inProgressSources">--</span></span>
            </span>
          </h2>
          <span class="refresh-time" id="sourcesRefresh"><div class="live-dot" id="sourcesLiveDot"></div><span id="sourcesRefreshText">--</span></span>
        </div>
        <div class="sources-controls">
          <input type="text" id="sourcesFilter" placeholder="Filter sources..." class="sources-filter-input">
          <select id="sourcesSort" class="sources-sort-select">
            <option value="progress">Sort: Progress ‚Üì</option>
            <option value="status">Sort: Status</option>
            <option value="name">Sort: Name</option>
            <option value="urls">Sort: URLs ‚Üì</option>
            <option value="html">Sort: HTML ‚Üì</option>
            <option value="builds">Sort: Builds ‚Üì</option>
          </select>
        </div>
      </div>
      <div class="card-body scrollable" id="sourcesList">
        Loading...
      </div>
    </div>
  </div>
  
  <script>
    // Configuration
    const REFRESH_INTERVAL = 5000; // 5 seconds
    const API_BASE = 'http://localhost:8765';
    
    // State
    let lastLogLines = [];
    let allSources = [];
    
    // Format numbers with commas
    function formatNumber(num) {
      if (num === null || num === undefined || num === 'null') return '--';
      return parseInt(num).toLocaleString();
    }
    
    // Settings Panel Toggle
    function toggleSettingsPanel() {
      const overlay = document.getElementById('settingsOverlay');
      overlay.classList.toggle('visible');
    }
    
    function closeSettingsPanel() {
      const overlay = document.getElementById('settingsOverlay');
      overlay.classList.remove('visible');
    }
    
    // ============================================
    // Browser Preview Panel (CDP WebSocket)
    // ============================================
    
    let browserWs = null;
    let browserSessionId = null;
    let screencastEnabled = false;
    let browserConnected = false;
    
    function toggleBrowserPanel() {
      const panel = document.getElementById('browserPanel');
      const btn = document.getElementById('browserBtn');
      panel.classList.toggle('visible');
      btn.classList.toggle('active', panel.classList.contains('visible'));
    }
    
    function closeBrowserPanel() {
      const panel = document.getElementById('browserPanel');
      const btn = document.getElementById('browserBtn');
      panel.classList.remove('visible');
      btn.classList.remove('active');
    }
    
    function browserLog(message, type = 'info') {
      const log = document.getElementById('browserLog');
      const time = new Date().toLocaleTimeString();
      const typeClass = type === 'error' ? 'browser-log-error' : 
                        type === 'success' ? 'browser-log-success' :
                        type === 'url' ? 'browser-log-url' : 
                        type === 'action' ? 'browser-log-action' : '';
      
      const entry = document.createElement('div');
      entry.className = 'browser-log-entry';
      entry.innerHTML = `<span class="browser-log-time">[${time}]</span><span class="${typeClass}">${message}</span>`;
      log.appendChild(entry);
      log.scrollTop = log.scrollHeight;
    }
    
    function updateBrowserStatus(connected, text) {
      browserConnected = connected;
      const dot = document.getElementById('browserStatusDot');
      const statusText = document.getElementById('browserStatusText');
      dot.className = 'browser-status-dot' + (connected ? ' connected' : '');
      statusText.textContent = text || (connected ? 'Connected' : 'Disconnected');
    }
    
    async function startBrowserSession() {
      browserLog('üöÄ Starting browser session...', 'action');
      updateBrowserStatus(false, 'Starting...');
      
      document.getElementById('browserLoading').style.display = 'block';
      document.getElementById('browserPlaceholder').style.display = 'none';
      
      try {
        // Request backend to start Chrome with CDP
        const response = await fetch(`${API_BASE}/browser/start`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });
        
        const data = await response.json();
        
        if (data.success) {
          browserLog(`‚úÖ Browser started on port ${data.port}`, 'success');
          browserLog(`WebSocket: ${data.ws_url}`, 'url');
          
          // Connect to CDP WebSocket
          await connectToCDP(data.ws_url);
          
          document.getElementById('startBrowserBtn').style.display = 'none';
          document.getElementById('stopBrowserBtn').style.display = 'inline-block';
        } else {
          throw new Error(data.error || 'Failed to start browser');
        }
      } catch (error) {
        browserLog(`‚ùå Error: ${error.message}`, 'error');
        updateBrowserStatus(false, 'Error');
        document.getElementById('browserLoading').style.display = 'none';
        document.getElementById('browserPlaceholder').style.display = 'block';
      }
    }
    
    async function connectToCDP(wsUrl) {
      return new Promise((resolve, reject) => {
        browserLog(`üîå Connecting to CDP: ${wsUrl}`, 'action');
        
        browserWs = new WebSocket(wsUrl);
        
        browserWs.onopen = () => {
          browserLog('‚úÖ CDP WebSocket connected', 'success');
          updateBrowserStatus(true, 'Connected');
          document.getElementById('browserLoading').style.display = 'none';
          
          // Enable page events
          sendCDPCommand('Page.enable');
          sendCDPCommand('Runtime.enable');
          sendCDPCommand('DOM.enable');
          
          // Start screencast for live preview
          startScreencast();
          
          resolve();
        };
        
        browserWs.onmessage = (event) => {
          handleCDPMessage(JSON.parse(event.data));
        };
        
        browserWs.onerror = (error) => {
          browserLog(`‚ùå WebSocket error`, 'error');
          updateBrowserStatus(false, 'Error');
          reject(error);
        };
        
        browserWs.onclose = () => {
          browserLog('üîå WebSocket disconnected', 'action');
          updateBrowserStatus(false, 'Disconnected');
          browserWs = null;
          screencastEnabled = false;
        };
      });
    }
    
    let cdpCommandId = 1;
    const cdpCallbacks = {};
    
    function sendCDPCommand(method, params = {}) {
      if (!browserWs || browserWs.readyState !== WebSocket.OPEN) {
        browserLog('‚ö†Ô∏è Not connected to browser', 'error');
        return Promise.reject(new Error('Not connected'));
      }
      
      const id = cdpCommandId++;
      
      return new Promise((resolve, reject) => {
        cdpCallbacks[id] = { resolve, reject };
        
        browserWs.send(JSON.stringify({
          id,
          method,
          params
        }));
      });
    }
    
    function handleCDPMessage(msg) {
      // Handle command responses
      if (msg.id && cdpCallbacks[msg.id]) {
        if (msg.error) {
          cdpCallbacks[msg.id].reject(new Error(msg.error.message));
        } else {
          cdpCallbacks[msg.id].resolve(msg.result);
        }
        delete cdpCallbacks[msg.id];
        return;
      }
      
      // Handle events
      if (msg.method) {
        switch (msg.method) {
          case 'Page.screencastFrame':
            handleScreencastFrame(msg.params);
            break;
          case 'Page.loadEventFired':
            browserLog('üìÑ Page loaded', 'success');
            break;
          case 'Page.frameNavigated':
            if (msg.params.frame.url) {
              document.getElementById('browserUrlBar').value = msg.params.frame.url;
              browserLog(`üîó Navigated to: ${msg.params.frame.url}`, 'url');
            }
            break;
        }
      }
    }
    
    function startScreencast() {
      if (screencastEnabled) return;
      
      sendCDPCommand('Page.startScreencast', {
        format: 'jpeg',
        quality: 60,
        maxWidth: 1200,
        maxHeight: 800,
        everyNthFrame: 2
      }).then(() => {
        screencastEnabled = true;
        browserLog('üì∫ Screencast started', 'success');
      }).catch(err => {
        browserLog(`‚ö†Ô∏è Screencast error: ${err.message}`, 'error');
      });
    }
    
    function handleScreencastFrame(params) {
      const img = document.getElementById('browserScreenshot');
      const placeholder = document.getElementById('browserPlaceholder');
      
      img.src = 'data:image/jpeg;base64,' + params.data;
      img.style.display = 'block';
      placeholder.style.display = 'none';
      
      // Acknowledge the frame
      sendCDPCommand('Page.screencastFrameAck', {
        sessionId: params.sessionId
      });
    }
    
    async function stopBrowserSession() {
      browserLog('üõë Stopping browser session...', 'action');
      
      if (screencastEnabled) {
        await sendCDPCommand('Page.stopScreencast').catch(() => {});
        screencastEnabled = false;
      }
      
      if (browserWs) {
        browserWs.close();
        browserWs = null;
      }
      
      // Tell backend to stop browser
      try {
        await fetch(`${API_BASE}/browser/stop`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });
      } catch (e) {
        console.error('Error stopping browser:', e);
      }
      
      updateBrowserStatus(false, 'Stopped');
      document.getElementById('browserScreenshot').style.display = 'none';
      document.getElementById('browserPlaceholder').style.display = 'block';
      document.getElementById('startBrowserBtn').style.display = 'inline-block';
      document.getElementById('stopBrowserBtn').style.display = 'none';
      browserLog('‚úÖ Browser session stopped', 'success');
    }
    
    async function browserNavigate() {
      const url = document.getElementById('browserUrlBar').value.trim();
      if (!url) return;
      
      // Add protocol if missing
      const fullUrl = url.startsWith('http') ? url : 'https://' + url;
      
      browserLog(`üåê Navigating to: ${fullUrl}`, 'action');
      document.getElementById('browserLoading').style.display = 'block';
      
      try {
        await sendCDPCommand('Page.navigate', { url: fullUrl });
      } catch (error) {
        browserLog(`‚ùå Navigation error: ${error.message}`, 'error');
      }
      
      document.getElementById('browserLoading').style.display = 'none';
    }
    
    async function browserBack() {
      browserLog('‚Üê Going back', 'action');
      try {
        const history = await sendCDPCommand('Page.getNavigationHistory');
        if (history.currentIndex > 0) {
          await sendCDPCommand('Page.navigateToHistoryEntry', {
            entryId: history.entries[history.currentIndex - 1].id
          });
        }
      } catch (error) {
        browserLog(`‚ùå Error: ${error.message}`, 'error');
      }
    }
    
    async function browserForward() {
      browserLog('‚Üí Going forward', 'action');
      try {
        const history = await sendCDPCommand('Page.getNavigationHistory');
        if (history.currentIndex < history.entries.length - 1) {
          await sendCDPCommand('Page.navigateToHistoryEntry', {
            entryId: history.entries[history.currentIndex + 1].id
          });
        }
      } catch (error) {
        browserLog(`‚ùå Error: ${error.message}`, 'error');
      }
    }
    
    async function browserRefresh() {
      browserLog('üîÑ Refreshing page', 'action');
      try {
        await sendCDPCommand('Page.reload');
      } catch (error) {
        browserLog(`‚ùå Error: ${error.message}`, 'error');
      }
    }
    
    async function browserSnapshot() {
      browserLog('üì∏ Taking screenshot...', 'action');
      try {
        const result = await sendCDPCommand('Page.captureScreenshot', {
          format: 'png',
          quality: 100
        });
        
        // Create download link
        const link = document.createElement('a');
        link.href = 'data:image/png;base64,' + result.data;
        link.download = `screenshot_${Date.now()}.png`;
        link.click();
        
        browserLog('‚úÖ Screenshot saved', 'success');
      } catch (error) {
        browserLog(`‚ùå Error: ${error.message}`, 'error');
      }
    }
    
    async function browserExecuteJS() {
      const js = prompt('Enter JavaScript to execute:');
      if (!js) return;
      
      browserLog(`‚ö° Executing: ${js.substring(0, 50)}...`, 'action');
      try {
        const result = await sendCDPCommand('Runtime.evaluate', {
          expression: js,
          returnByValue: true
        });
        
        const value = result.result.value;
        browserLog(`‚úÖ Result: ${JSON.stringify(value).substring(0, 200)}`, 'success');
        console.log('JS Result:', value);
      } catch (error) {
        browserLog(`‚ùå Error: ${error.message}`, 'error');
      }
    }
    
    async function browserExtractDOM() {
      browserLog('üîç Extracting DOM structure...', 'action');
      try {
        const doc = await sendCDPCommand('DOM.getDocument', { depth: -1 });
        
        // Get outer HTML
        const html = await sendCDPCommand('DOM.getOuterHTML', {
          nodeId: doc.root.nodeId
        });
        
        // Save to file via API
        const response = await fetch(`${API_BASE}/browser/save-dom`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            html: html.outerHTML,
            url: document.getElementById('browserUrlBar').value
          })
        });
        
        const data = await response.json();
        browserLog(`‚úÖ DOM saved to: ${data.path}`, 'success');
      } catch (error) {
        browserLog(`‚ùå Error: ${error.message}`, 'error');
      }
    }
    
    // Close browser panel on Escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && document.getElementById('browserPanel').classList.contains('visible')) {
        closeBrowserPanel();
      }
    });
    
    // ============================================
    // End Browser Preview Panel
    // ============================================
    
    // Close settings on Escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && document.getElementById('settingsOverlay').classList.contains('visible')) {
        closeSettingsPanel();
      }
    });
    
    // Populate sources dropdown for Ralph
    function populateSourcesDropdown(sources) {
      // Populate Ralph source selector
      populateRalphSourceSelector(sources);
    }
    
    // Populate Ralph source selector (multi-select)
    function populateRalphSourceSelector(sources) {
      const select = document.getElementById('ralphSource');
      const currentSelections = Array.from(select.selectedOptions).map(o => o.value);
      
      select.innerHTML = '';
      
      // Sort by status (pending/in_progress first), then by name
      const sortedSources = [...sources].sort((a, b) => {
        const statusOrder = { 'in_progress': 0, 'pending': 1, 'blocked': 2, 'completed': 3 };
        const aOrder = statusOrder[a.status] ?? 99;
        const bOrder = statusOrder[b.status] ?? 99;
        if (aOrder !== bOrder) return aOrder - bOrder;
        return a.name.localeCompare(b.name);
      });
      
      sortedSources.forEach(source => {
        const option = document.createElement('option');
        option.value = source.id;
        const pipeline = source.pipeline || {};
        const urlCount = pipeline.urlsFound || 0;
        const htmlCount = pipeline.htmlScraped || 0;
        const buildCount = pipeline.builds || 0;
        
        // Status indicator
        const statusIcon = {
          'in_progress': 'üîÑ',
          'pending': '‚è≥',
          'blocked': 'üö´',
          'completed': '‚úÖ'
        }[source.status] || '‚ùì';
        
        option.textContent = `${statusIcon} ${source.name} (URLs:${urlCount} HTML:${htmlCount} Builds:${buildCount})`;
        
        // Restore selection
        if (currentSelections.includes(source.id)) {
          option.selected = true;
        }
        
        select.appendChild(option);
      });
    }
    
    // Start Ralph
    async function startRalph() {
      const iterations = parseInt(document.getElementById('ralphIterations').value) || 25;
      const sourceSelect = document.getElementById('ralphSource');
      const selectedSources = Array.from(sourceSelect.selectedOptions).map(o => o.value).filter(v => v);
      
      const config = {
        iterations: iterations,
        sources: selectedSources
      };
      
      try {
        const response = await fetch(`${API_BASE}/ralph/start`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(config)
        });
        
        const data = await response.json();
        
        if (data.success) {
          updateRalphUI(true, data.pid);
        } else {
          alert('Failed to start Ralph: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        alert('Error starting Ralph: ' + error.message);
      }
    }
    
    // Stop Ralph
    async function stopRalph() {
      try {
        const response = await fetch(`${API_BASE}/ralph/stop`, {
          method: 'POST'
        });
        
        const data = await response.json();
        updateRalphUI(false);
      } catch (error) {
        alert('Error stopping Ralph: ' + error.message);
      }
    }
    
    // Update Ralph UI state
    function updateRalphUI(running, pid = null) {
      const statusDot = document.getElementById('ralphStatusDot');
      const statusDot2 = document.getElementById('ralphStatusDot2');
      const statusText = document.getElementById('ralphStatusText');
      const pidText = document.getElementById('ralphPid');
      const startBtn = document.getElementById('startRalphBtn');
      const stopBtn = document.getElementById('stopRalphBtn');
      
      if (running) {
        statusDot.className = 'status-dot running';
        statusDot2.className = 'scraper-status-dot running';
        statusText.textContent = 'Running';
        pidText.textContent = pid ? `PID: ${pid}` : '';
        startBtn.style.display = 'none';
        stopBtn.style.display = 'flex';
      } else {
        statusDot.className = 'status-dot stopped';
        statusDot2.className = 'scraper-status-dot stopped';
        statusText.textContent = 'Stopped';
        pidText.textContent = '';
        startBtn.style.display = 'flex';
        stopBtn.style.display = 'none';
      }
    }
    
    // Update Ralph status from server
    async function updateRalphStatus() {
      try {
        const response = await fetch(`${API_BASE}/ralph/status`);
        const data = await response.json();
        
        updateRalphUI(data.running, data.pid);
        
        if (data.prd && data.prd.project) {
          document.getElementById('ralphProject').textContent = data.prd.project;
          document.getElementById('ralphStoryProgress').textContent = 
            `Stories: ${data.prd.stories_completed}/${data.prd.stories_total} | Source: ${data.prd.source || 'N/A'}`;
        } else {
          document.getElementById('ralphProject').textContent = 'No active project';
          document.getElementById('ralphStoryProgress').textContent = '--';
        }
      } catch (error) {
        console.error('Failed to fetch Ralph status:', error);
      }
    }
    
    // Log refresh controls
    let autoRefreshEnabled = true;
    let autoScrollEnabled = true;
    
    function toggleAutoRefresh() {
      autoRefreshEnabled = !autoRefreshEnabled;
      const btn = document.getElementById('autoRefreshBtn');
      btn.classList.toggle('active', autoRefreshEnabled);
    }
    
    function clearLogDisplay() {
      document.getElementById('logOutput').innerHTML = '<span class="info">Log cleared. Waiting for new data...</span>';
    }
    
    async function killAllRalphs() {
      const btn = document.getElementById('killAllBtn');
      const originalText = btn.innerHTML;
      
      if (!confirm('‚ò†Ô∏è Kill ALL Ralph processes?\n\nThis will terminate:\n‚Ä¢ All ralph.sh loops\n‚Ä¢ All Claude CLI processes\n‚Ä¢ All Python scrapers\n\nAre you sure?')) {
        return;
      }
      
      btn.classList.add('killing');
      btn.innerHTML = '‚ò†Ô∏è Killing...';
      
      try {
        const response = await fetch(`${API_BASE}/ralph/kill-all`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });
        const data = await response.json();
        
        if (data.success) {
          btn.innerHTML = '‚ò†Ô∏è Killed!';
          setTimeout(() => {
            btn.classList.remove('killing');
            btn.innerHTML = originalText;
          }, 2000);
          
          // Add message to log
          const logOutput = document.getElementById('logOutput');
          const killMsg = document.createElement('div');
          killMsg.innerHTML = `<span class="error">[${new Date().toLocaleTimeString()}] ‚ò†Ô∏è KILL ALL: ${data.message}</span>`;
          logOutput.appendChild(killMsg);
          logOutput.scrollTop = logOutput.scrollHeight;
        } else {
          throw new Error(data.error || 'Unknown error');
        }
      } catch (error) {
        console.error('Kill all failed:', error);
        btn.classList.remove('killing');
        btn.innerHTML = '‚ùå Failed';
        setTimeout(() => { btn.innerHTML = originalText; }, 2000);
      }
    }
    
    async function refreshLogNow() {
      try {
        const response = await fetch(`${API_BASE}/log/fresh?lines=200`);
        const data = await response.json();
        
        if (data.log) {
          const logOutput = document.getElementById('logOutput');
          logOutput.innerHTML = colorizeLog(data.log);
          if (autoScrollEnabled) {
            logOutput.scrollTop = logOutput.scrollHeight;
          }
          document.getElementById('logRefresh').textContent = `Updated: ${new Date().toLocaleTimeString()} (${data.total_lines || '?'} lines)`;
        }
      } catch (error) {
        console.error('Failed to refresh log:', error);
      }
    }
    
    // Generate PRD using browser analysis
    async function generatePRD() {
      const sourceSelect = document.getElementById('ralphSource');
      const selectedSources = Array.from(sourceSelect.selectedOptions).map(o => o.value).filter(v => v);
      
      if (selectedSources.length === 0) {
        alert('Please select a source first');
        return;
      }
      
      if (selectedSources.length > 1) {
        alert('Please select only one source for PRD generation');
        return;
      }
      
      const sourceId = selectedSources[0];
      const source = allSources.find(s => s.id === sourceId);
      
      if (!source) {
        alert('Source not found');
        return;
      }
      
      // Show status
      const statusDiv = document.getElementById('prdGenStatus');
      const statusText = document.getElementById('prdGenStatusText');
      statusDiv.style.display = 'block';
      statusText.textContent = `Analyzing ${source.name}...`;
      
      try {
        const response = await fetch(`${API_BASE}/prd/generate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sourceId: sourceId,
            url: source.url,
            name: source.name,
            useBrowser: true
          })
        });
        
        const data = await response.json();
        
        if (data.success) {
          statusText.innerHTML = `<span class="success">‚úì PRD generated for ${source.name}</span>`;
          setTimeout(() => {
            statusDiv.style.display = 'none';
            updateRalphStatus();
          }, 3000);
        } else {
          statusText.innerHTML = `<span class="error">‚úó ${data.error || 'Failed to generate PRD'}</span>`;
        }
      } catch (error) {
        statusText.innerHTML = `<span class="error">‚úó Error: ${error.message}</span>`;
      }
    }
    
    // ANSI color code to CSS class mapping
    const ANSI_COLORS = {
      '30': 'color: #1a1a2e',      // black
      '31': 'color: #ff6b6b',      // red
      '32': 'color: #4ade80',      // green
      '33': 'color: #fbbf24',      // yellow
      '34': 'color: #60a5fa',      // blue
      '35': 'color: #c084fc',      // magenta
      '36': 'color: #22d3ee',      // cyan
      '37': 'color: #e5e5e5',      // white
      '90': 'color: #6b7280',      // bright black (gray)
      '91': 'color: #f87171',      // bright red
      '92': 'color: #4ade80',      // bright green
      '93': 'color: #facc15',      // bright yellow
      '94': 'color: #93c5fd',      // bright blue
      '95': 'color: #e879f9',      // bright magenta
      '96': 'color: #67e8f9',      // bright cyan
      '97': 'color: #ffffff',      // bright white
    };

    // Convert ANSI escape codes to HTML spans
    function ansiToHtml(text) {
      // Handle both \x1b[ and raw [0; patterns
      let result = text;
      let openSpans = 0;

      // Match ANSI escape sequences: \x1b[...m or \033[...m or raw [digits;digitsm patterns
      result = result.replace(/\x1b\[([0-9;]*)m|\[([0-9]+;?[0-9]*)m/g, (match, p1, p2) => {
        const codes = (p1 || p2 || '').split(';').filter(c => c);

        // Reset code
        if (codes.length === 0 || codes.includes('0')) {
          const closeSpans = '</span>'.repeat(openSpans);
          openSpans = 0;
          return closeSpans;
        }

        // Build style from codes
        let styles = [];
        for (const code of codes) {
          if (code === '1') styles.push('font-weight: bold');
          else if (code === '2') styles.push('opacity: 0.7');
          else if (code === '3') styles.push('font-style: italic');
          else if (code === '4') styles.push('text-decoration: underline');
          else if (ANSI_COLORS[code]) styles.push(ANSI_COLORS[code]);
        }

        if (styles.length > 0) {
          openSpans++;
          return `<span style="${styles.join('; ')}">`;
        }
        return '';
      });

      // Close any remaining open spans
      result += '</span>'.repeat(openSpans);

      return result;
    }

    // Colorize log output
    function colorizeLog(text) {
      // First convert ANSI codes to HTML
      let result = ansiToHtml(text);

      // Then apply keyword highlighting (only if not already colored by ANSI)
      return result
        .replace(/‚úì|‚úÖ|SUCCESS|COMPLETE/gi, '<span class="success">$&</span>')
        .replace(/‚ùå|ERROR|FAIL|BLOCKED/gi, '<span class="error">$&</span>')
        .replace(/‚ö†Ô∏è|WARNING|WARN/gi, '<span class="warning">$&</span>')
        .replace(/‚ÑπÔ∏è|INFO|‚Üí/gi, '<span class="info">$&</span>')
        .replace(/(Stage \d)/gi, '<span class="info">$1</span>')
        .replace(/(\d+\/\d+)/g, '<span class="success">$1</span>');
    }
    
    // Update dashboard
    async function updateDashboard() {
      try {
        const response = await fetch(`${API_BASE}/status`);
        const data = await response.json();
        
        // Update status
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        if (data.running) {
          statusDot.className = 'status-dot running';
          statusText.textContent = 'Running';
        } else {
          statusDot.className = 'status-dot stopped';
          statusText.textContent = 'Stopped';
        }
        
        // Update stats
        document.getElementById('totalSources').textContent = data.sources.total;
        document.getElementById('completedSources').textContent = data.sources.completed;
        document.getElementById('inProgressSources').textContent = data.sources.in_progress;
        
        // Update pipeline stages with TOTALS
        // Use top-level data fields (from API) for accurate totals
        let totalUrls = 0;
        if (data.all_sources && data.all_sources.length > 0) {
          data.all_sources.forEach(source => {
            const pipeline = source.pipeline || {};
            totalUrls += pipeline.urlsFound || 0;
          });
        }
        
        // Use data fields directly for HTML, Builds, Mods (matches actual file counts)
        const totalHtml = data.html_files || 0;
        const totalBuilds = data.total_builds || data.builds || 0;
        const totalMods = data.total_mods || data.mods || 0;
        
        updateStage('stage1', totalUrls, null);
        updateStage('stage2', totalHtml, totalUrls);
        updateStage('stage3', totalBuilds, null);
        updateStage('stage4', totalMods, null);
        
        // Update sources list
        updateSourcesList(data.all_sources || []);
        
        // Populate Ralph source selector
        if (data.all_sources) {
          allSources = data.all_sources;
          populateSourcesDropdown(data.all_sources);
        }
        
        // Update log (use fresh endpoint for better updates)
        if (autoRefreshEnabled) {
          refreshLogNow();
        }
        
        // Update Ralph status
        updateRalphStatus();
        
        // Update refresh times
        const now = new Date().toLocaleTimeString();
        document.getElementById('sourcesRefreshText').textContent = `Live ¬∑ ${now}`;
        document.getElementById('sourcesLiveDot').className = 'live-dot';
        
      } catch (error) {
        console.error('Failed to fetch status:', error);
        document.getElementById('statusDot').className = 'status-dot stopped';
        document.getElementById('statusText').textContent = 'API Offline';
        document.getElementById('sourcesLiveDot').className = 'live-dot error';
        document.getElementById('sourcesRefreshText').textContent = 'Offline';
      }
    }
    
    function updateStage(id, current, total) {
      const stage = document.getElementById(id);
      const valueEl = stage.querySelector('.header-stage-value');
      
      if (current !== null && current !== undefined && current !== 'null') {
        valueEl.textContent = formatNumber(current);
        if (total && current >= total) {
          stage.className = 'header-stage complete';
        } else if (current > 0) {
          stage.className = 'header-stage active';
        } else {
          stage.className = 'header-stage';
        }
      } else {
        valueEl.textContent = '--';
        stage.className = 'header-stage';
      }
    }
    
    // Sources state for filtering/sorting
    let allSourcesData = [];
    let currentFilter = '';
    let currentSort = 'progress';
    
    // Initialize filter and sort event listeners
    document.getElementById('sourcesFilter').addEventListener('input', (e) => {
      currentFilter = e.target.value.toLowerCase();
      renderSourcesList();
    });
    
    document.getElementById('sourcesSort').addEventListener('change', (e) => {
      currentSort = e.target.value;
      renderSourcesList();
    });
    
    function updateSourcesList(sources) {
      allSourcesData = sources;
      renderSourcesList();
    }
    
    function renderSourcesList() {
      const container = document.getElementById('sourcesList');
      
      // Filter sources
      let filtered = allSourcesData.filter(source => {
        if (!currentFilter) return true;
        return source.name.toLowerCase().includes(currentFilter) ||
               (source.id && source.id.toLowerCase().includes(currentFilter));
      });
      
      // Sort sources
      filtered.sort((a, b) => {
        const pipeA = a.pipeline || {};
        const pipeB = b.pipeline || {};
        
        switch (currentSort) {
          case 'name':
            return a.name.localeCompare(b.name);
          case 'urls':
            return (pipeB.urlsFound || 0) - (pipeA.urlsFound || 0);
          case 'html':
            return (pipeB.htmlScraped || 0) - (pipeA.htmlScraped || 0);
          case 'builds':
            return (pipeB.builds || 0) - (pipeA.builds || 0);
          case 'progress':
            const progA = pipeA.urlsFound ? (pipeA.htmlScraped || 0) / pipeA.urlsFound : 0;
            const progB = pipeB.urlsFound ? (pipeB.htmlScraped || 0) / pipeB.urlsFound : 0;
            return progB - progA;
          case 'status':
          default:
            const order = { in_progress: 0, pending: 1, blocked: 2, completed: 3 };
            const diff = (order[a.status] || 99) - (order[b.status] || 99);
            if (diff !== 0) return diff;
            return a.name.localeCompare(b.name);
        }
      });
      
      // Render sources
      if (filtered.length === 0) {
        container.innerHTML = `<div class="no-results">No sources matching "${currentFilter}"</div>`;
        return;
      }
      
      container.innerHTML = filtered.map(source => {
        const pipeline = source.pipeline || {};
        const progress = pipeline.urlsFound ? 
          Math.round((pipeline.htmlScraped || 0) / pipeline.urlsFound * 100) : 0;
        
        return `
          <div class="source-item" data-source-id="${source.id}"
               onclick="openPrdModal('${source.id}', '${source.name.replace(/'/g, "\\'")}', '${(source.url || '').replace(/'/g, "\\'")}')"
               title="Click to view PRD for ${source.name}">
            <div class="source-info">
              <div class="source-status ${source.status}" 
                   data-source-id="${source.id}"
                   data-source-name="${source.name}"
                   data-source-url="${source.url || ''}"
                   data-source-status="${source.status}"
                   onclick="event.stopPropagation(); showSourceMenu(event, this)"
                   title="Click for actions"></div>
              <div>
                <div class="source-name">${source.name}</div>
                <div class="source-stats">
                  URLs: ${formatNumber(pipeline.urlsFound)} | 
                  HTML: ${formatNumber(pipeline.htmlScraped)} |
                  Builds: ${formatNumber(pipeline.builds)}
                </div>
              </div>
            </div>
            <div class="progress-bar">
              <div class="progress-bar-fill" style="width: ${progress}%"></div>
            </div>
          </div>
        `;
      }).join('');
    }
    
    // Initial load and start refresh
    updateDashboard();
    setInterval(updateDashboard, REFRESH_INTERVAL);
    
    // ==========================================
    // Source Action Menu
    // ==========================================
    
    let activeSourceMenu = null;
    
    function showSourceMenu(event, element) {
      event.stopPropagation();
      
      const sourceId = element.dataset.sourceId;
      const sourceName = element.dataset.sourceName;
      const sourceUrl = element.dataset.sourceUrl;
      const sourceStatus = element.dataset.sourceStatus;
      
      const menu = document.getElementById('sourceActionMenu');
      activeSourceMenu = { id: sourceId, name: sourceName, url: sourceUrl, status: sourceStatus };
      
      // Update menu content
      document.getElementById('menuSourceName').textContent = sourceName;
      document.getElementById('menuSourceUrl').textContent = sourceUrl || 'No URL';
      
      // Show/hide actions based on status
      const startBtn = document.getElementById('menuStartRalph');
      const stopBtn = document.getElementById('menuStopRalph');
      const generateBtn = document.getElementById('menuGeneratePrd');
      
      // Check if Ralph is currently running
      const ralphRunning = document.getElementById('statusText').textContent === 'Running';
      const isCurrentSource = sourceStatus === 'in_progress';
      
      if (ralphRunning && isCurrentSource) {
        // This source is currently running - show stop option
        startBtn.classList.add('disabled');
        stopBtn.classList.remove('disabled');
      } else if (ralphRunning) {
        // Ralph is running on a different source - disable start
        startBtn.classList.add('disabled');
        startBtn.querySelector('.label').textContent = 'Ralph busy...';
        stopBtn.classList.remove('disabled');
      } else {
        // Ralph not running - show start option
        startBtn.classList.remove('disabled');
        startBtn.querySelector('.label').textContent = 'Start Ralph';
        stopBtn.classList.add('disabled');
      }
      
      // Position menu near the clicked element
      const rect = element.getBoundingClientRect();
      menu.style.left = `${rect.left + 20}px`;
      menu.style.top = `${rect.top - 10}px`;
      
      // Ensure menu stays within viewport
      const menuRect = menu.getBoundingClientRect();
      if (menuRect.right > window.innerWidth) {
        menu.style.left = `${window.innerWidth - 220}px`;
      }
      if (menuRect.bottom > window.innerHeight) {
        menu.style.top = `${rect.top - menuRect.height - 10}px`;
      }
      
      menu.classList.add('visible');
    }
    
    function hideSourceMenu() {
      const menu = document.getElementById('sourceActionMenu');
      menu.classList.remove('visible');
      activeSourceMenu = null;
    }
    
    // Close menu when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.source-action-menu') && !e.target.closest('.source-status')) {
        hideSourceMenu();
      }
    });
    
    // Close menu on escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') hideSourceMenu();
    });
    
    async function startRalphForSource() {
      if (!activeSourceMenu) return;
      
      const { id, name, url } = activeSourceMenu;
      hideSourceMenu();
      
      // Show loading state
      showNotification(`üöÄ Starting Ralph for ${name}...`, 'info');
      
      try {
        // Start Ralph with the selected source
        const response = await fetch(`${API_BASE}/ralph/start`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            iterations: 25,
            sources: [id]
          })
        });
        
        const data = await response.json();
        
        if (data.success) {
          showNotification(`‚úÖ Ralph started for ${name}`, 'success');
          // Refresh dashboard to show new state
          setTimeout(updateDashboard, 1000);
        } else {
          showNotification(`‚ùå Failed: ${data.error}`, 'error');
        }
      } catch (err) {
        showNotification(`‚ùå Error: ${err.message}`, 'error');
      }
    }
    
    async function stopRalph() {
      hideSourceMenu();
      
      showNotification('üõë Stopping Ralph...', 'info');
      
      try {
        const response = await fetch(`${API_BASE}/ralph/stop`, {
          method: 'POST'
        });
        
        const data = await response.json();
        
        if (data.success) {
          showNotification('‚úÖ Ralph stopped', 'success');
          setTimeout(updateDashboard, 1000);
        } else {
          showNotification(`‚ùå Failed: ${data.error}`, 'error');
        }
      } catch (err) {
        showNotification(`‚ùå Error: ${err.message}`, 'error');
      }
    }
    
    async function generatePrdForSource() {
      if (!activeSourceMenu) return;
      
      const { id, name, url } = activeSourceMenu;
      hideSourceMenu();
      
      // Open the PRD editor modal
      openPrdModal(id, name, url);
    }
    
    function viewSourceData() {
      if (!activeSourceMenu) return;
      
      const { id, url } = activeSourceMenu;
      hideSourceMenu();
      
      // Open source URL in new tab
      if (url) {
        window.open(url, '_blank');
      }
    }
    
    // Notification system
    function showNotification(message, type = 'info') {
      const existing = document.querySelector('.notification');
      if (existing) existing.remove();
      
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.innerHTML = message;
      document.body.appendChild(notification);
      
      setTimeout(() => notification.classList.add('visible'), 10);
      setTimeout(() => {
        notification.classList.remove('visible');
        setTimeout(() => notification.remove(), 300);
      }, 4000);
    }
  </script>
  
  <!-- Settings Panel -->
  <div id="settingsOverlay" class="settings-overlay" onclick="if(event.target === this) closeSettingsPanel()">
    <div class="settings-panel">
      <div class="settings-header">
        <h2>‚öôÔ∏è Settings</h2>
        <button class="settings-close" onclick="closeSettingsPanel()">√ó</button>
      </div>
      <div class="settings-content">
        <!-- Ralph Loop Section -->
        <div class="settings-section">
          <div class="settings-section-title">ü§ñ Ralph Loop Configuration</div>
          
          <!-- Status Bar -->
          <div class="ralph-status" style="margin-bottom: 16px;">
            <div class="ralph-status-indicator">
              <div class="scraper-status-dot" id="ralphStatusDot2"></div>
            </div>
            <div class="ralph-info">
              <div class="project-name" id="ralphProject">No active project</div>
              <div class="story-progress" id="ralphStoryProgress">--</div>
            </div>
            <div class="status-badge" style="padding: 4px 12px; margin-left: auto;">
              <div class="status-dot" id="ralphStatusDot"></div>
              <span id="ralphStatusText" style="font-size: 11px;">Checking...</span>
            </div>
          </div>
          
          <!-- Source Selection -->
          <div class="form-group" style="margin-bottom: 16px;">
            <label>Target Source(s)</label>
            <select id="ralphSource" multiple size="6" style="width: 100%;">
              <option value="">Loading sources...</option>
            </select>
            <span class="help-text">Hold Ctrl/Cmd to select multiple. Leave empty to use current PRD.</span>
          </div>
          
          <!-- Iterations Config -->
          <div class="iterations-input" style="margin-bottom: 16px;">
            <label>Max Iterations:</label>
            <input type="number" id="ralphIterations" value="25" min="1" max="100">
            <span class="help-text">Ralph will stop after this many iterations</span>
          </div>
          
          <!-- Action Buttons -->
          <div class="btn-group" style="flex-wrap: wrap; gap: 8px;">
            <button class="btn btn-secondary" onclick="generatePRD()" title="Use browser to analyze site and generate PRD">
              üåê Generate PRD
            </button>
            <button class="btn btn-primary" id="startRalphBtn" onclick="startRalph()" style="background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));">
              ‚ñ∂Ô∏è Start Ralph
            </button>
            <button class="btn btn-danger" id="stopRalphBtn" onclick="stopRalph()" style="display: none;">
              ‚èπÔ∏è Stop Ralph
            </button>
          </div>
          
          <!-- PRD Generation Status -->
          <div id="prdGenStatus" style="display: none; margin-top: 16px; padding: 12px; background: var(--bg-primary); border-radius: 8px;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <div class="scraper-status-dot running"></div>
              <span id="prdGenStatusText">Analyzing site...</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Source Action Menu -->
  <div id="sourceActionMenu" class="source-action-menu">
    <div class="source-action-menu-header">
      <div class="name" id="menuSourceName">Source Name</div>
      <div class="url" id="menuSourceUrl">https://example.com</div>
    </div>
    <div class="source-action-item start" id="menuStartRalph" onclick="startRalphForSource()">
      <span class="icon">‚ñ∂Ô∏è</span>
      <span class="label">Start Ralph</span>
    </div>
    <div class="source-action-item stop disabled" id="menuStopRalph" onclick="stopRalph()">
      <span class="icon">‚èπÔ∏è</span>
      <span class="label">Stop Ralph</span>
    </div>
    <div class="source-action-divider"></div>
    <div class="source-action-item generate" id="menuGeneratePrd" onclick="generatePrdForSource()">
      <span class="icon">üîß</span>
      <span class="label">Generate PRD</span>
    </div>
    <div class="source-action-item view" onclick="viewSourceData()">
      <span class="icon">üåê</span>
      <span class="label">Visit Website</span>
    </div>
  </div>
  
  <!-- Browser Preview Panel (CDP) -->
  <div id="browserPanel" class="browser-panel">
    <div class="browser-header">
      <h2>üåê Browser Preview</h2>
      <div class="browser-status">
        <div class="browser-status-dot" id="browserStatusDot"></div>
        <span id="browserStatusText">Disconnected</span>
      </div>
      <button class="browser-close" onclick="closeBrowserPanel()">√ó</button>
    </div>
    
    <div class="browser-toolbar">
      <button onclick="browserBack()" title="Back">‚Üê</button>
      <button onclick="browserForward()" title="Forward">‚Üí</button>
      <button onclick="browserRefresh()" title="Refresh">üîÑ</button>
      <input type="text" class="browser-url-bar" id="browserUrlBar" placeholder="Enter URL..." onkeypress="if(event.key==='Enter')browserNavigate()">
      <button onclick="browserNavigate()">Go</button>
      <button onclick="browserSnapshot()" title="Take Snapshot">üì∏</button>
    </div>
    
    <div class="browser-viewport">
      <div class="browser-screenshot-container" id="browserScreenshotContainer">
        <div class="browser-screenshot-placeholder" id="browserPlaceholder">
          <div class="icon">üåê</div>
          <div>Browser Preview</div>
          <div style="margin-top: 12px; font-size: 12px;">
            <button onclick="startBrowserSession()" style="padding: 8px 16px; background: var(--accent-cyan); border: none; border-radius: 6px; color: var(--bg-primary); cursor: pointer; font-weight: 600;">
              üöÄ Start Browser Session
            </button>
          </div>
          <div style="margin-top: 8px; font-size: 11px; opacity: 0.7;">
            Uses Chrome DevTools Protocol for live preview
          </div>
        </div>
        <img id="browserScreenshot" class="browser-screenshot" style="display: none;" alt="Browser Screenshot">
        <div id="browserLoading" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
          <div style="font-size: 24px; animation: pulse 1s infinite;">‚è≥</div>
          <div style="margin-top: 8px; font-size: 12px; color: var(--text-muted);">Loading...</div>
        </div>
      </div>
      
      <div class="browser-log" id="browserLog">
        <div class="browser-log-entry">
          <span class="browser-log-time">[--:--:--]</span>
          <span>Browser panel ready. Click "Start Browser Session" to begin.</span>
        </div>
      </div>
    </div>
    
    <div class="browser-controls">
      <button onclick="browserExecuteJS()" title="Execute JavaScript">
        ‚ö° Execute JS
      </button>
      <button onclick="browserExtractDOM()" title="Extract DOM Structure">
        üîç Extract DOM
      </button>
      <button class="danger" onclick="stopBrowserSession()" id="stopBrowserBtn" style="display: none;">
        ‚èπÔ∏è Stop Session
      </button>
      <button class="primary" onclick="startBrowserSession()" id="startBrowserBtn">
        üöÄ Start Session
      </button>
    </div>
  </div>
  
  <style>
    .notification {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      padding: 12px 24px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      font-size: 14px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.4);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 2000;
    }
    
    .notification.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    
    .notification.success { border-color: var(--accent-green); }
    .notification.error { border-color: var(--accent-red); }
    .notification.info { border-color: var(--accent-cyan); }
    
    /* PRD Editor Modal */
    .prd-modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(4px);
      z-index: 3000;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }
    
    .prd-modal-overlay.visible {
      display: flex;
      animation: fadeIn 0.2s ease-out;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .prd-modal {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      width: 100%;
      max-width: 1200px;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      animation: modalSlide 0.3s ease-out;
    }
    
    @keyframes modalSlide {
      from { opacity: 0; transform: translateY(-20px) scale(0.95); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }
    
    .prd-modal-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .prd-modal-header h2 {
      font-size: 18px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .prd-modal-header .source-badge {
      background: var(--bg-secondary);
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 12px;
      color: var(--accent-cyan);
      font-family: 'JetBrains Mono', monospace;
    }
    
    .prd-modal-close {
      width: 32px;
      height: 32px;
      border: none;
      background: var(--bg-secondary);
      border-radius: 8px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 18px;
      transition: all 0.2s;
    }
    
    .prd-modal-close:hover {
      background: var(--accent-red);
      color: white;
    }
    
    .prd-modal-body {
      display: grid;
      grid-template-columns: 280px 1fr;
      flex: 1;
      overflow: hidden;
    }
    
    .prd-sidebar {
      border-right: 1px solid var(--border);
      padding: 20px;
      overflow-y: auto;
      background: var(--bg-secondary);
    }
    
    .prd-sidebar h3 {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-muted);
      margin-bottom: 12px;
    }
    
    .prd-variables {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .prd-variable {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .prd-variable label {
      font-size: 12px;
      color: var(--text-secondary);
      font-family: 'JetBrains Mono', monospace;
    }
    
    .prd-variable input, .prd-variable select {
      padding: 8px 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      font-size: 13px;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .prd-variable input:focus, .prd-variable select:focus {
      outline: none;
      border-color: var(--accent-cyan);
    }
    
    .prd-actions-sidebar {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .prd-action-btn {
      padding: 10px 16px;
      border: 1px solid var(--border);
      background: var(--bg-primary);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 13px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s;
    }
    
    .prd-action-btn:hover {
      border-color: var(--accent-cyan);
      background: var(--bg-card);
    }
    
    .prd-action-btn.primary {
      background: var(--accent-cyan);
      border-color: var(--accent-cyan);
      color: black;
      font-weight: 600;
    }
    
    .prd-action-btn.primary:hover {
      background: #1cb5cc;
    }
    
    .prd-action-btn.danger {
      color: var(--accent-red);
    }
    
    .prd-action-btn.danger:hover {
      background: var(--accent-red);
      border-color: var(--accent-red);
      color: white;
    }
    
    .prd-main {
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .prd-tabs {
      display: flex;
      border-bottom: 1px solid var(--border);
      padding: 0 20px;
      background: var(--bg-secondary);
    }
    
    .prd-tab {
      padding: 12px 20px;
      border: none;
      background: none;
      color: var(--text-muted);
      font-size: 13px;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      margin-bottom: -1px;
      transition: all 0.2s;
    }
    
    .prd-tab:hover {
      color: var(--text-primary);
    }
    
    .prd-tab.active {
      color: var(--accent-cyan);
      border-bottom-color: var(--accent-cyan);
    }
    
    .prd-content {
      flex: 1;
      overflow: hidden;
      position: relative;
    }
    
    .prd-panel {
      position: absolute;
      inset: 0;
      padding: 20px;
      overflow-y: auto;
      display: none;
    }
    
    .prd-panel.active {
      display: block;
    }
    
    .prd-editor {
      width: 100%;
      height: 100%;
      min-height: 400px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      line-height: 1.6;
      resize: none;
    }
    
    .prd-editor:focus {
      outline: none;
      border-color: var(--accent-cyan);
    }
    
    .prd-stream {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      line-height: 1.6;
      white-space: pre-wrap;
      min-height: 400px;
      position: relative;
    }
    
    .prd-stream .cursor {
      display: inline-block;
      width: 8px;
      height: 16px;
      background: var(--accent-cyan);
      animation: blink 1s infinite;
      vertical-align: middle;
      margin-left: 2px;
    }
    
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }
    
    .prd-stream-status {
      position: absolute;
      top: 12px;
      right: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      color: var(--text-muted);
    }
    
    .prd-stream-status .dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent-green);
      animation: pulse 1.5s infinite;
    }
    
    .prd-preview {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 20px;
    }
    
    .prd-preview h4 {
      font-size: 14px;
      margin-bottom: 16px;
      color: var(--accent-cyan);
    }
    
    .prd-stories {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .prd-story {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
    }
    
    .prd-story-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }
    
    .prd-story-id {
      background: var(--accent-purple);
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .prd-story-title {
      font-weight: 500;
    }
    
    .prd-story-criteria {
      font-size: 12px;
      color: var(--text-muted);
      margin-left: 20px;
    }
    
    .prd-story-criteria li {
      margin: 4px 0;
    }
    
    .prd-modal-footer {
      padding: 16px 24px;
      border-top: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--bg-secondary);
    }
    
    .prd-footer-info {
      font-size: 12px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 16px;
    }
    
    .prd-footer-actions {
      display: flex;
      gap: 12px;
    }
  </style>
  
  <!-- PRD Editor Modal -->
  <div id="prdModal" class="prd-modal-overlay">
    <div class="prd-modal">
      <div class="prd-modal-header">
        <h2>
          üîß PRD Generator
          <span class="source-badge" id="prdSourceBadge">source_name</span>
        </h2>
        <button class="prd-modal-close" onclick="closePrdModal()">√ó</button>
      </div>
      
      <div class="prd-modal-body">
        <div class="prd-sidebar">
          <h3>üìã Variables</h3>
          <div class="prd-variables" id="prdVariables">
            <div class="prd-variable">
              <label>{{source_id}}</label>
              <input type="text" id="varSourceId" placeholder="source_id">
            </div>
            <div class="prd-variable">
              <label>{{source_name}}</label>
              <input type="text" id="varSourceName" placeholder="Source Name">
            </div>
            <div class="prd-variable">
              <label>{{source_url}}</label>
              <input type="text" id="varSourceUrl" placeholder="https://example.com">
            </div>
            <div class="prd-variable">
              <label>{{output_dir}}</label>
              <input type="text" id="varOutputDir" placeholder="data/source_name">
            </div>
            <div class="prd-variable">
              <label>{{scrape_mode}}</label>
              <select id="varScrapeMode">
                <option value="standard">Standard (httpx)</option>
                <option value="stealth">Stealth (Camoufox)</option>
                <option value="aggressive">Aggressive Stealth</option>
              </select>
            </div>
            <div class="prd-variable">
              <label>{{priority}}</label>
              <select id="varPriority">
                <option value="1">1 - Highest</option>
                <option value="2">2 - High</option>
                <option value="3" selected>3 - Normal</option>
                <option value="4">4 - Low</option>
                <option value="5">5 - Lowest</option>
              </select>
            </div>
          </div>
          
          <div class="prd-actions-sidebar">
            <h3 style="margin-top: 0;">‚ö° Actions</h3>
            <button class="prd-action-btn" onclick="generatePrd()">
              üîÑ Generate PRD
            </button>
            <button class="prd-action-btn" onclick="generatePrdVariant()">
              üé≤ Generate Variant
            </button>
            <button class="prd-action-btn" onclick="analyzeSiteStructure()">
              üîç Analyze Site
            </button>
            <button class="prd-action-btn danger" onclick="clearPrdEditor()">
              üóëÔ∏è Clear
            </button>
          </div>
        </div>
        
        <div class="prd-main">
          <div class="prd-tabs">
            <button class="prd-tab active" onclick="switchPrdTab('stream')">üî¥ Live Stream</button>
            <button class="prd-tab" onclick="switchPrdTab('editor')">üìù Editor</button>
            <button class="prd-tab" onclick="switchPrdTab('preview')">üëÅÔ∏è Preview</button>
          </div>
          
          <div class="prd-content">
            <div class="prd-panel active" id="prdStreamPanel">
              <div class="prd-stream" id="prdStreamContent">
                <span class="prd-stream-status" id="prdStreamStatus" style="display: none;">
                  <span class="dot"></span>
                  Generating...
                </span>
                <span id="prdStreamText">Click "Generate PRD" to start...</span>
                <span class="cursor" id="prdCursor" style="display: none;"></span>
              </div>
            </div>
            
            <div class="prd-panel" id="prdEditorPanel">
              <textarea class="prd-editor" id="prdEditorContent" placeholder="PRD JSON will appear here after generation..."></textarea>
            </div>
            
            <div class="prd-panel" id="prdPreviewPanel">
              <div class="prd-preview" id="prdPreviewContent">
                <p style="color: var(--text-muted);">Generate a PRD to see the preview...</p>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="prd-modal-footer">
        <div class="prd-footer-info">
          <span id="prdStatus">Ready</span>
          <span id="prdTimestamp">--</span>
        </div>
        <div class="prd-footer-actions">
          <button class="prd-action-btn" onclick="closePrdModal()">Cancel</button>
          <button class="prd-action-btn" onclick="savePrdToFile()">üíæ Save to File</button>
          <button class="prd-action-btn primary" onclick="usePrdAndStartRalph()">üöÄ Use & Start Ralph</button>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // ==========================================
    // PRD Editor Modal
    // ==========================================
    
    let currentPrdSource = null;
    let prdGenerationAbort = null;
    let currentPrdContent = '';
    
    async function openPrdModal(sourceId, sourceName, sourceUrl) {
      currentPrdSource = { id: sourceId, name: sourceName, url: sourceUrl };
      
      // Update modal header
      document.getElementById('prdSourceBadge').textContent = sourceId;
      
      // Pre-fill variables
      document.getElementById('varSourceId').value = sourceId;
      document.getElementById('varSourceName').value = sourceName;
      document.getElementById('varSourceUrl').value = sourceUrl || '';
      document.getElementById('varOutputDir').value = `data/${sourceId}`;
      
      // Reset content
      document.getElementById('prdStreamText').textContent = 'Checking for existing analysis...';
      document.getElementById('prdEditorContent').value = '';
      document.getElementById('prdPreviewContent').innerHTML = '<p style="color: var(--text-muted);">Generate a PRD to see the preview...</p>';
      document.getElementById('prdStreamStatus').style.display = 'flex';
      document.getElementById('prdCursor').style.display = 'inline-block';
      document.getElementById('prdStatus').textContent = 'Loading...';
      document.getElementById('prdTimestamp').textContent = '--';
      
      // Show modal
      document.getElementById('prdModal').classList.add('visible');
      switchPrdTab('stream');
      
      // Wait 0.5 seconds then start automated workflow
      await new Promise(r => setTimeout(r, 500));
      await runAutomatedPrdWorkflow(sourceId, sourceName, sourceUrl);
    }
    
    // Automated PRD workflow
    async function runAutomatedPrdWorkflow(sourceId, sourceName, sourceUrl) {
      const streamEl = document.getElementById('prdStreamText');
      currentPrdContent = '';
      
      try {
        // Step 1: Check if domain analysis exists
        await streamText(streamEl, `üîç Checking for ${sourceId}_domain_analysis.md...\n`);
        
        const analysisResponse = await fetch(`${API_BASE}/prd/check-file`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ filename: `${sourceId}_domain_analysis.md` })
        });
        const analysisCheck = await analysisResponse.json();
        
        let hasAnalysis = analysisCheck.exists;
        
        if (!hasAnalysis) {
          await streamText(streamEl, `\n‚ùå No domain analysis found.\n`);
          await streamText(streamEl, `\nüåê Starting domain analysis for ${sourceName}...\n`);
          await streamText(streamEl, `   Target: ${sourceUrl || 'No URL'}\n\n`);
          
          // Run domain analysis
          const analyzeResponse = await fetch(`${API_BASE}/prd/analyze-domain`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
              sourceId, 
              sourceName, 
              sourceUrl,
              stream: true 
            })
          });
          
          if (analyzeResponse.ok) {
            // Stream the analysis response
            const reader = analyzeResponse.body?.getReader();
            if (reader) {
              const decoder = new TextDecoder();
              while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                const text = decoder.decode(value);
                await streamText(streamEl, text, 0);
              }
            } else {
              const result = await analyzeResponse.json();
              await streamText(streamEl, result.analysis || '‚úÖ Analysis complete.\n');
            }
            hasAnalysis = true;
            await streamText(streamEl, `\n\n‚úÖ Domain analysis saved to ${sourceId}_domain_analysis.md\n`);
          } else {
            await streamText(streamEl, `\n‚ö†Ô∏è Analysis API not available. Using template-based PRD.\n`);
          }
        } else {
          await streamText(streamEl, `‚úÖ Found existing domain analysis.\n`);
          
          // Show snippet of existing analysis
          if (analysisCheck.content) {
            const preview = analysisCheck.content.substring(0, 500);
            await streamText(streamEl, `\nüìÑ Analysis preview:\n${'‚îÄ'.repeat(40)}\n${preview}...\n${'‚îÄ'.repeat(40)}\n`);
          }
        }
        
        // Step 2: Check if PRD exists
        await streamText(streamEl, `\nüîç Checking for ${sourceId}_prd.md...\n`);
        
        const prdResponse = await fetch(`${API_BASE}/prd/check-file`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ filename: `${sourceId}_prd.md` })
        });
        const prdCheck = await prdResponse.json();
        
        if (!prdCheck.exists) {
          await streamText(streamEl, `\n‚ùå No PRD found.\n`);
          await streamText(streamEl, `\nü§ñ Generating PRD from domain analysis...\n\n`);
          
          // Generate PRD from analysis
          const generateResponse = await fetch(`${API_BASE}/prd/generate-from-analysis`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
              sourceId, 
              sourceName, 
              sourceUrl,
              stream: true 
            })
          });
          
          if (generateResponse.ok) {
            // Stream the PRD generation
            const reader = generateResponse.body?.getReader();
            if (reader) {
              const decoder = new TextDecoder();
              let prdContent = '';
              while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                const text = decoder.decode(value);
                prdContent += text;
                await streamText(streamEl, text, 0);
              }
              // Try to parse and show in editor
              try {
                document.getElementById('prdEditorContent').value = prdContent;
                const prd = JSON.parse(prdContent);
                updatePrdPreview(prd);
              } catch (e) {
                // Not JSON, might be markdown
                document.getElementById('prdEditorContent').value = prdContent;
              }
            } else {
              const result = await generateResponse.json();
              if (result.prd) {
                const prdJson = JSON.stringify(result.prd, null, 2);
                await streamText(streamEl, prdJson);
                document.getElementById('prdEditorContent').value = prdJson;
                updatePrdPreview(result.prd);
              }
            }
            await streamText(streamEl, `\n\n‚úÖ PRD saved to ${sourceId}_prd.md\n`);
          } else {
            // Fallback to template-based PRD
            await streamText(streamEl, `\n‚ö†Ô∏è PRD generation API not available. Using template...\n\n`);
            const vars = getVariables();
            const template = createPrdTemplate(vars);
            await streamPrdGeneration(template, vars);
          }
        } else {
          await streamText(streamEl, `‚úÖ Found existing PRD.\n`);
          
          // Load and display existing PRD
          if (prdCheck.content) {
            await streamText(streamEl, `\nüìã Loading PRD...\n\n`);
            await streamText(streamEl, prdCheck.content);
            document.getElementById('prdEditorContent').value = prdCheck.content;
            try {
              const prd = JSON.parse(prdCheck.content);
              updatePrdPreview(prd);
            } catch (e) {
              // Markdown format
            }
          }
        }
        
        // Done
        document.getElementById('prdStreamStatus').style.display = 'none';
        document.getElementById('prdCursor').style.display = 'none';
        document.getElementById('prdStatus').textContent = 'Ready';
        document.getElementById('prdTimestamp').textContent = new Date().toLocaleTimeString();
        
      } catch (error) {
        console.error('PRD workflow error:', error);
        await streamText(streamEl, `\n\n‚ùå Error: ${error.message}\n`);
        await streamText(streamEl, `\n‚ö†Ô∏è Falling back to template-based PRD generation.\n\n`);
        
        // Fallback to simple template
        document.getElementById('prdStreamStatus').style.display = 'none';
        document.getElementById('prdCursor').style.display = 'none';
        document.getElementById('prdStatus').textContent = 'Ready (template mode)';
      }
    }
    
    // Helper to stream text character by character
    async function streamText(element, text, delay = 5) {
      for (const char of text) {
        currentPrdContent += char;
        element.textContent = currentPrdContent;
        element.parentElement.scrollTop = element.parentElement.scrollHeight;
        if (delay > 0) {
          await new Promise(r => setTimeout(r, char === '\n' ? delay * 4 : delay));
        }
      }
    }
    
    function closePrdModal() {
      document.getElementById('prdModal').classList.remove('visible');
      if (prdGenerationAbort) {
        prdGenerationAbort.abort();
        prdGenerationAbort = null;
      }
      currentPrdSource = null;
    }
    
    function switchPrdTab(tab) {
      // Update tabs
      document.querySelectorAll('.prd-tab').forEach(t => t.classList.remove('active'));
      document.querySelector(`.prd-tab[onclick="switchPrdTab('${tab}')"]`).classList.add('active');
      
      // Update panels
      document.querySelectorAll('.prd-panel').forEach(p => p.classList.remove('active'));
      document.getElementById(`prd${tab.charAt(0).toUpperCase() + tab.slice(1)}Panel`).classList.add('active');
    }
    
    function getVariables() {
      return {
        source_id: document.getElementById('varSourceId').value,
        source_name: document.getElementById('varSourceName').value,
        source_url: document.getElementById('varSourceUrl').value,
        output_dir: document.getElementById('varOutputDir').value,
        scrape_mode: document.getElementById('varScrapeMode').value,
        priority: document.getElementById('varPriority').value
      };
    }
    
    async function generatePrd() {
      const vars = getVariables();
      
      // Reset and show streaming
      switchPrdTab('stream');
      document.getElementById('prdStreamText').textContent = '';
      document.getElementById('prdStreamStatus').style.display = 'flex';
      document.getElementById('prdCursor').style.display = 'inline-block';
      document.getElementById('prdStatus').textContent = 'Generating...';
      
      currentPrdContent = '';
      
      // Create PRD template with variables
      const template = createPrdTemplate(vars);
      
      // Simulate streaming (in production, this would connect to a real streaming endpoint)
      await streamPrdGeneration(template, vars);
    }
    
    function createPrdTemplate(vars) {
      return {
        projectName: `${vars.source_name} Scraping`,
        sourceId: vars.source_id,
        branchName: "main",
        targetUrl: vars.source_url,
        outputDir: vars.output_dir,
        scrapeMode: vars.scrape_mode,
        priority: parseInt(vars.priority),
        userStories: [
          {
            id: "URL-001",
            title: "Discover all vehicle/build URLs on the site",
            acceptanceCriteria: [
              "urls.jsonl contains all discoverable URLs",
              "URLs are deduplicated and normalized",
              "Pagination/infinite scroll handled"
            ],
            priority: 1,
            passes: false
          },
          {
            id: "HTML-001", 
            title: "Scrape HTML for all discovered URLs",
            acceptanceCriteria: [
              "HTML files saved for each URL",
              vars.scrape_mode !== 'standard' ? "Use stealth scraper for anti-bot protection" : "Use standard httpx scraper",
              "Rate limiting: 2-5 second delays"
            ],
            priority: 1,
            passes: false
          },
          {
            id: "BUILD-001",
            title: "Extract structured build data from HTML",
            acceptanceCriteria: [
              "builds.jsonl contains vehicle data",
              "Required fields: build_id, year, make, model, source_url",
              "Images extracted to gallery_images array"
            ],
            priority: 1,
            passes: false
          },
          {
            id: "MOD-001",
            title: "Extract modifications from builds",
            acceptanceCriteria: [
              "mods.jsonl contains modification data",
              "Categories: Engine, Suspension, Wheels, etc.",
              "Brand and part names extracted where available"
            ],
            priority: 2,
            passes: false
          }
        ],
        variables: vars,
        createdAt: new Date().toISOString(),
        createdBy: "dashboard-prd-generator"
      };
    }
    
    async function streamPrdGeneration(template, vars) {
      const streamEl = document.getElementById('prdStreamText');
      const jsonStr = JSON.stringify(template, null, 2);
      
      // Stream character by character
      for (let i = 0; i < jsonStr.length; i++) {
        if (prdGenerationAbort?.signal.aborted) break;
        
        currentPrdContent += jsonStr[i];
        streamEl.textContent = currentPrdContent;
        
        // Scroll to bottom
        streamEl.parentElement.scrollTop = streamEl.parentElement.scrollHeight;
        
        // Variable speed based on character
        const char = jsonStr[i];
        let delay = 2;
        if (char === '\n') delay = 20;
        else if (char === '{' || char === '}') delay = 30;
        else if (char === ',') delay = 15;
        
        await new Promise(r => setTimeout(r, delay));
      }
      
      // Done streaming
      document.getElementById('prdStreamStatus').style.display = 'none';
      document.getElementById('prdCursor').style.display = 'none';
      document.getElementById('prdStatus').textContent = 'Generated';
      document.getElementById('prdTimestamp').textContent = new Date().toLocaleTimeString();
      
      // Update editor and preview
      document.getElementById('prdEditorContent').value = currentPrdContent;
      updatePrdPreview(template);
    }
    
    function updatePrdPreview(prd) {
      const previewEl = document.getElementById('prdPreviewContent');
      
      const storiesHtml = prd.userStories.map(story => `
        <div class="prd-story">
          <div class="prd-story-header">
            <span class="prd-story-id">${story.id}</span>
            <span class="prd-story-title">${story.title}</span>
          </div>
          <ul class="prd-story-criteria">
            ${story.acceptanceCriteria.map(c => `<li>‚úì ${c}</li>`).join('')}
          </ul>
        </div>
      `).join('');
      
      previewEl.innerHTML = `
        <h4>üìã ${prd.projectName}</h4>
        <div style="margin-bottom: 16px; font-size: 13px; color: var(--text-secondary);">
          <strong>Target:</strong> ${prd.targetUrl || 'Not set'}<br>
          <strong>Output:</strong> ${prd.outputDir}<br>
          <strong>Mode:</strong> ${prd.scrapeMode}
        </div>
        <h4 style="margin-top: 20px;">üìù User Stories</h4>
        <div class="prd-stories">
          ${storiesHtml}
        </div>
      `;
    }
    
    async function generatePrdVariant() {
      const vars = getVariables();
      
      // Create a variant with different strategies
      const strategies = ['aggressive', 'conservative', 'parallel', 'sequential'];
      const strategy = strategies[Math.floor(Math.random() * strategies.length)];
      
      vars.variant_strategy = strategy;
      
      showNotification(`üé≤ Generating ${strategy} variant...`, 'info');
      await generatePrd();
    }
    
    async function analyzeSiteStructure() {
      if (!currentPrdSource?.url) {
        showNotification('‚ùå No source URL to analyze', 'error');
        return;
      }
      
      const streamEl = document.getElementById('prdStreamText');
      switchPrdTab('stream');
      document.getElementById('prdStreamStatus').style.display = 'flex';
      document.getElementById('prdCursor').style.display = 'inline-block';
      document.getElementById('prdStatus').textContent = 'Analyzing...';
      
      // Simulate site analysis
      const analysisSteps = [
        `üîç Analyzing ${currentPrdSource.url}...\n`,
        `üì° Fetching homepage...\n`,
        `‚úÖ Page loaded successfully\n\n`,
        `üìä Site Analysis Results:\n`,
        `${'‚îÄ'.repeat(40)}\n`,
        `Domain: ${new URL(currentPrdSource.url).hostname}\n`,
        `Protocol: ${new URL(currentPrdSource.url).protocol}\n\n`,
        `üîé Detected Patterns:\n`,
        `  ‚Ä¢ Pagination: Yes (likely)\n`,
        `  ‚Ä¢ JavaScript: Heavy usage detected\n`,
        `  ‚Ä¢ Anti-bot: Unknown (needs testing)\n\n`,
        `üìù Recommended Configuration:\n`,
        `  ‚Ä¢ Scrape Mode: stealth\n`,
        `  ‚Ä¢ Rate Limit: 3-5 seconds\n`,
        `  ‚Ä¢ Concurrent: 2-3 browsers\n\n`,
        `‚ú® Analysis complete. Click "Generate PRD" to create a tailored PRD.`
      ];
      
      currentPrdContent = '';
      streamEl.textContent = '';
      
      for (const step of analysisSteps) {
        for (const char of step) {
          currentPrdContent += char;
          streamEl.textContent = currentPrdContent;
          streamEl.parentElement.scrollTop = streamEl.parentElement.scrollHeight;
          await new Promise(r => setTimeout(r, char === '\n' ? 50 : 10));
        }
      }
      
      document.getElementById('prdStreamStatus').style.display = 'none';
      document.getElementById('prdCursor').style.display = 'none';
      document.getElementById('prdStatus').textContent = 'Analysis complete';
      document.getElementById('prdTimestamp').textContent = new Date().toLocaleTimeString();
    }
    
    function clearPrdEditor() {
      currentPrdContent = '';
      document.getElementById('prdStreamText').textContent = 'Click "Generate PRD" to start...';
      document.getElementById('prdEditorContent').value = '';
      document.getElementById('prdPreviewContent').innerHTML = '<p style="color: var(--text-muted);">Generate a PRD to see the preview...</p>';
      document.getElementById('prdStatus').textContent = 'Ready';
      document.getElementById('prdTimestamp').textContent = '--';
    }
    
    async function savePrdToFile() {
      const content = document.getElementById('prdEditorContent').value;
      if (!content) {
        showNotification('‚ùå No PRD content to save', 'error');
        return;
      }
      
      try {
        const prd = JSON.parse(content);
        
        const response = await fetch(`${API_BASE}/prd/save`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prd })
        });
        
        if (response.ok) {
          showNotification('‚úÖ PRD saved to scripts/ralph/prd.json', 'success');
        } else {
          // Fallback: download as file
          const blob = new Blob([content], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `prd_${currentPrdSource?.id || 'unknown'}.json`;
          a.click();
          URL.revokeObjectURL(url);
          showNotification('üì• PRD downloaded as file', 'info');
        }
      } catch (err) {
        showNotification(`‚ùå Invalid JSON: ${err.message}`, 'error');
      }
    }
    
    async function usePrdAndStartRalph() {
      const content = document.getElementById('prdEditorContent').value;
      if (!content) {
        showNotification('‚ùå No PRD content', 'error');
        return;
      }
      
      try {
        const prd = JSON.parse(content);
        
        // Save PRD first
        await fetch(`${API_BASE}/prd/save`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prd })
        });
        
        closePrdModal();
        
        // Start Ralph
        showNotification(`üöÄ Starting Ralph for ${prd.sourceId}...`, 'info');
        
        const response = await fetch(`${API_BASE}/ralph/start`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            iterations: 25,
            sources: [prd.sourceId]
          })
        });
        
        const data = await response.json();
        
        if (data.success) {
          showNotification(`‚úÖ Ralph started for ${prd.sourceId}`, 'success');
          setTimeout(updateDashboard, 1000);
        } else {
          showNotification(`‚ùå Failed: ${data.error}`, 'error');
        }
      } catch (err) {
        showNotification(`‚ùå Error: ${err.message}`, 'error');
      }
    }
    
    // Close modal on overlay click
    document.getElementById('prdModal').addEventListener('click', (e) => {
      if (e.target.id === 'prdModal') {
        closePrdModal();
      }
    });
    
    // Close modal on Escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && document.getElementById('prdModal').classList.contains('visible')) {
        closePrdModal();
      }
    });
  </script>
</body>
</html>

